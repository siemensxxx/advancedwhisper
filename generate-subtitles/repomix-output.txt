This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-11T23:12:59.087Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
constants/
  constants.js
  ytdlpUsers.txt
docs/
  install-libretranslate
  install.sh
  libretranslate-nginx
  nginx-whisper-and-libretranslate.conf
  readme.md
  thing.conf
downloading/
  download.js
  yt-dlp-download.js
examples/
  dnevnik.srt
helpers/
  formatStdErr.js
  getLanguageNames.js
  helpers.js
lib/
  convertText.js
  files.js
  stats.js
  transcribing.js
  websockets.js
public/
  javascripts/
    circle-progress.min.js
  stylesheets/
    style.css
  robots.txt
queue/
  newQueue.js
  queue.js
routes/
  admin.js
  api.js
  index.js
  player.js
  stats.js
  transcribe.js
  users.js
scripts/
  deleteTranscriptionUploads.js
  extractAudioFfmpeg.js
  postAudioFile.js
  srtToVtt.js
transcribe/
  transcribe-api-wrapped.js
  transcribe-via-api.js
  transcribe-wrapped.js
  transcribing.js
translate/
  create-translated-files.js
  google-translate-browser.js
  helpers.js
  libreTranslateWrapper.js
  translate-files-api.js
views/
  addTranslation/
    addTranslation.pug
  index/
    components/
      amounts-header.pug
      social-buttons.pug
      transcription-results.pug
      upload-form.pug
    js/
      controllers/
        error-handling.pug
        file-handling.pug
        network-handling.pug
        selection-dropdowns.pug
      js-index.pug
      js-util.pug
    styles/
      styles-amounts-header.pug
      styles-form.pug
      styles-social.pug
      styles-transcription-results.pug
    index.pug
  player/
    js/
      captionsDisplay.pug
      secondCaptions.pug
      videoProgress.pug
    player.pug
    styles-player.pug
  stats/
    stats.pug
  styles/
    styles-global.pug
  admin.pug
  error.pug
  files.pug
  layout.pug
  queue.pug
.env.sample
.eslintrc.js
.gitignore
app.js
package.json
README.md

================================================================
Repository Files
================================================================

================
File: constants/constants.js
================
const languageNameMap = require('language-name-map/map')

l = console.log;

/** STUFF FOR WHISPER **/
const whisperLanguagesString = 'af,am,ar,as,az,ba,be,bg,bn,bo,br,bs,ca,cs,cy,da,de,el,en,es,et,eu,fa,fi,fo,fr,gl,gu,ha,haw,hi,hr,ht,hu,hy,id,is,it,iw,ja,jw,ka,kk,km,kn,ko,la,lb,ln,lo,lt,lv,mg,mi,mk,ml,mn,mr,ms,mt,my,ne,nl,nn,no,oc,pa,pl,ps,pt,ro,ru,sa,sd,si,sk,sl,sn,so,sq,sr,su,sv,sw,ta,te,tg,th,tk,tl,tr,tt,uk,ur,uz,vi,yi,yo,zh';

const whisperLanguagesHumanNames = 'Afrikaans,Albanian,Amharic,Arabic,Armenian,Assamese,Azerbaijani,Bashkir,Basque,Belarusian,Bengali,Bosnian,Breton,Bulgarian,Burmese,Castilian,Catalan,Chinese,Croatian,Czech,Danish,Dutch,English,Estonian,Faroese,Finnish,Flemish,French,Galician,Georgian,German,Greek,Gujarati,Haitian,Haitian Creole,Hausa,Hawaiian,Hebrew,Hindi,Hungarian,Icelandic,Indonesian,Italian,Japanese,Javanese,Kannada,Kazakh,Khmer,Korean,Lao,Latin,Latvian,Letzeburgesch,Lingala,Lithuanian,Luxembourgish,Macedonian,Malagasy,Malay,Malayalam,Maltese,Maori,Marathi,Moldavian,Moldovan,Mongolian,Myanmar,Nepali,Norwegian,Nynorsk,Occitan,Panjabi,Pashto,Persian,Polish,Portuguese,Punjabi,Pushto,Romanian,Russian,Sanskrit,Serbian,Shona,Sindhi,Sinhala,Sinhalese,Slovak,Slovenian,Somali,Spanish,Sundanese,Swahili,Swedish,Tagalog,Tajik,Tamil,Tatar,Telugu,Thai,Tibetan,Turkish,Turkmen,Ukrainian,Urdu,Uzbek,Valencian,Vietnamese,Welsh,Yiddish,Yoruba';

const whisperLanguagesHumanReadableArray = whisperLanguagesHumanNames.split(',');
const whisperLanguagesAsSpacedString = whisperLanguagesHumanReadableArray.join(' ')
const languagesArray = whisperLanguagesHumanReadableArray.map(lang => ({value: lang, name: lang}));
languagesArray.unshift({value: 'auto-detect', name: 'Auto-Detect'});

function getLanguageCodeForAllLanguages (languageName) {
  let foundLanguageCode;
  Object.keys(languageNameMap).forEach(languageCode =>{
    if (languageNameMap[languageCode].name === languageName) {
      foundLanguageCode = languageCode
    }
  });
  return foundLanguageCode
}

const whisperModelsString = 'tiny.en,tiny,base.en,base,small.en,small,medium.en,medium,large';
const modelsArray = [
  {name: 'Tiny (English Only)', value: 'tiny.en'},
  {name: 'Tiny', value: 'tiny'},
  {name: 'Base (English Only)', value: 'base.en'},
  {name: 'Base', value: 'base'},
  {name: 'Small (English Only)', value: 'small.en'},
  {name: 'Small', value: 'small'},
  {name: 'Medium (English Only)', value: 'medium.en'},
  {name: 'Medium', value: 'medium'},
  {name: 'Large', value: 'large'},
];

// available models in Libretranslate
const translationLanguages = [
  {'code':'ar','name':'Arabic'},
  {'code':'az','name':'Azerbaijani'},
  {'code':'zh','name':'Chinese'},
  {'code':'cs','name':'Czech'},
  {'code':'da','name':'Danish'},
  {'code':'nl','name':'Dutch'},
  {'code':'en','name':'English'},
  {'code':'fi','name':'Finnish'},
  {'code':'fr','name':'French'},
  {'code':'de','name':'German'},
  {'code':'el','name':'Greek'},
  {'code':'he','name':'Hebrew'},
  {'code':'hi','name':'Hindi'},
  {'code':'hu','name':'Hungarian'},
  {'code':'id','name':'Indonesian'},
  {'code':'ga','name':'Irish'},
  {'code':'it','name':'Italian'},
  {'code':'ja','name':'Japanese'},
  {'code':'ko','name':'Korean'},
  {'code':'fa','name':'Persian'},
  {'code':'pl','name':'Polish'},
  {'code':'pt','name':'Portuguese'},
  {'code':'ru','name':'Russian'},
  {'code':'sk','name':'Slovak'},
  {'code':'es','name':'Spanish'},
  {'code':'sv','name':'Swedish'},
  {'code':'tr','name':'Turkish'},
  {'code':'uk','name':'Ukranian'}
];

const languagesToTranslateTo = [
  // {"code":"ar","name":"Arabic"}, // haven't got these two to work
  // {"code":"zh","name":"Chinese"}, // webvtt format is too broken after translate
  {'code':'en','name':'English'},
  {'code':'fr','name':'French'},
  {'code':'de','name':'German'},
  {'code':'es','name':'Spanish'},
  {'code':'ru','name':'Russian'},
  {'code':'ja','name':'Japanese'},
];

// if the human readable name matches thing (or the 'en' version, transcribe
const languagesToTranscribe = [
  'Arabic',
  'English',
  'French',
  'German',
  'Spanish',
  'Russian',
  'Chinese',
  'Japanese',
  'Serbian'
]

// function shouldTranslateFrom(languageName){
//   return translationLanguages.find(function(filteredLanguage){
//     return languageName === filteredLanguage.name;
//   })
// }

function shouldTranslateFrom (languageName) {
  return languagesToTranslateTo.includes(languageName);
}

let newLanguagesMap = [];
Object.keys(languageNameMap).forEach(languageCode =>{
  newLanguagesMap.push({
    languageCode,
    name: languageNameMap[languageCode].name
  })
});

let allLanguages = [];
Object.keys(languageNameMap).forEach(languageCode =>{
  allLanguages.push({
    code: languageCode,
    name: languageNameMap[languageCode].name
  })
});

// l('all languages length');
// l(allLanguages.length);

// l('newLanguagesMap', newLanguagesMap);

// const languagesToTranscribeFrom =

module.exports = {
  whisperLanguagesHumanNames,
  languagesArray,
  languagesToTranscribe,
  whisperLanguagesAsSpacedString,
  shouldTranslateFrom,
  translationLanguages,
  getLanguageCodeForAllLanguages,
  newLanguagesMap,
  allLanguages,
  modelsArray,
  languagesToTranslateTo,
  whisperLanguagesHumanReadableArray
}

================
File: constants/ytdlpUsers.txt
================
Aahedalhamamy

================
File: docs/install-libretranslate
================
# python install-models.py
# python main.py

# from browser
const res = await fetch("http://76.50.42.128:49627/translate", {
	method: "POST",
	body: JSON.stringify({
		q: "Hey here is some translated text!",
		source: "auto",
		target: "es"
	}),
	headers: { "Content-Type": "application/json" }
});

console.log(await res.json());

================
File: docs/install.sh
================
wget -qO - http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/3bf863cc.pub | sudo apt-key add -
sudo apt-get update
sudo apt-get upgrade -y
sudo add-apt-repository ppa:deadsnakes/ppa -y
sudo apt install nodejs npm nginx ffmpeg software-properties-common python3 python3.9 python3-pip python3.9-distutils python3.9-dev pkg-config libicu-dev lsof nano -y
sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.9 1000
pip3 install setuptools-rust
pip3 install --upgrade setuptools
curl https://sh.rustup.rs -sSf | sh -s -- -y
# setting alias this way doesn't work
alias pip=pip3
alias python=python3.9
python -m pip install --upgrade pip
pip3 install --upgrade setuptools
pip install git+https://github.com/openai/whisper.git

whisper
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash

# this is broken I believe
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

nvm install 16
nvm use 16
npm install -g http-server pm2


sudo curl -L https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp -o /usr/local/bin/yt-dlp
sudo chmod a+rx /usr/local/bin/yt-dlp  # Make executable
git clone https://github.com/mayeaux/generate-subtitles

export LIBRETRANSLATE='http://127.0.0.1:5000'
export CONCURRENT_AMOUNT='2'
export NODE_ENV='production'

pm2 start npm -- start

# for libretranslate
#sudo apt-get install python3.9-dev -y
#pip3 install --upgrade distlib
#apt-get install pkg-config libicu-dev
#pip3 install libretranslate

================
File: docs/libretranslate-nginx
================
server {
    listen 80;
    server_name _;

    location / {
        # 30 minute timeout (1800 seconds)
        proxy_connect_timeout       1800;
        proxy_send_timeout          1800;
        proxy_read_timeout          1800;
        send_timeout                1800;


        include proxy_params;
        proxy_pass http://localhost:5000;
    }
}

================
File: docs/nginx-whisper-and-libretranslate.conf
================
server {
    listen 80 default_server;
    listen [::]:80 default_server;

    server_name _;
    error_page  405     =200 $uri;

    # max size of 3GB file
    client_max_body_size 3000M;

    # set root to serve files out of
    root /root/generate-subtitles;

    # serve files using nginx instead of node static
    location /transcriptions/ {
        gzip off;

        sendfile           on;
        sendfile_max_chunk 1m;

        tcp_nopush on;

        limit_rate 7m;
        limit_rate_after 30m;

        charset utf-8;
        types {
                    text/plain vtt;
                    text/plain srt;
                    text/plain txt;
              }

        try_files $uri @redirect;
    }

    # assumes libretranslate running on port 5000
    location /translate {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    location @redirect {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # node app running on port 3000
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}

================
File: docs/readme.md
================
```
const ltEndpoint = 'https://freesubtitles.ai/translate'; 

const res = await fetch(ltEndpoint, {
    method: "POST",
    body: JSON.stringify({
        q: "Hey here is some translated text!",
        source: "auto",
        target: "es"
    }),
    headers: { "Content-Type": "application/json" }
});

console.log(await res.json());
```

================
File: docs/thing.conf
================
# if the files are separate, this is in sites-available

# this file is for your server block, in combo with the http block

server {
	listen 80;
	listen [::]:80;

	server_name videoapp.video;

	listen 443 ssl;

    ssl_certificate /home/videoapp/certs/videoapp_video_chain.crt;
    ssl_certificate_key /home/videoapp/certs/server.key;

    ##
    # Nginx Bad Bot Blocker Includes
    # REPO: https://github.com/mitchellkrogza/nginx-ultimate-bad-bot-blocker
    ##
	#include /etc/nginx/bots.d/ddos.conf;
 	#include /etc/nginx/bots.d/blockbots.conf;

    error_page  405     =200 $uri;

    # IMPORTANT: set location for the uploads
	root /home/videoapp;

    location /files/ {
        gzip off;

        sendfile           on;
        sendfile_max_chunk 1m;

        tcp_nopush on;


        try_files $uri @redirect;
    }

    location @redirect {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

	location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        client_max_body_size 8500M;
    }
}

server {
	listen 80 default_server;
	listen [::]:80 default_server;

	server_name freesubtitles.ai;

    error_page  405     =200 $uri;

    location @redirect {
        proxy_pass http://serverAPI:19801; #port 80
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

	location / {
        proxy_pass http://serverAPI:19801; #port 80
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}

================
File: downloading/download.js
================
const YTDlpWrap = require('yt-dlp-wrap').default;
const which = require('which')
// const transcribe = require('./transcribe');

l = console.log;

// async usage
// rejects if not found
const ytDlpName = process.platform === 'win32' ? 'YoutubeDL' : 'yt-dlp';
const ytDlpBinaryPath = which.sync(ytDlpName);

const ytDlpWrap = new YTDlpWrap(ytDlpBinaryPath);

const testUrl = 'https://www.youtube.com/watch?v=P7ny6-lKoe4';

function download (videoUrl, filename) {
  let ytDlpEventEmitter = ytDlpWrap
    .exec([
      videoUrl,
      '-f',
      'bestaudio / b',
      '-o',
      filename
    ])
    .on('progress', (progress) =>
      console.log(
        progress.percent,
        progress.totalSize,
        progress.currentSpeed,
        progress.eta
      )
    )
    .on('ytDlpEvent', (eventType, eventData) =>
      console.log(eventType, eventData)
    )
    .on('error', (error) => console.error(error))
    .on('close', () => {
      l('done!');
      transcribe(filename)
    });

  // console.log(ytDlpEventEmitter.ytDlpProcess.pid);
}

async function download (videoUrl, filename) {
  let stdout = await ytDlpWrap.execPromise([
    videoUrl,
    '-f',
    'bestaudio / b',
    '-o',
    filename
  ]);

  l(stdout);

  return true

  // console.log(ytDlpEventEmitter.ytDlpProcess.pid);
}

async function getTitle (videoUrl) {
  let metadata = await ytDlpWrap.getVideoInfo(videoUrl, '--format', 'bestaudio / b');

  // l(metadata);
  // l(metadata.title);
  // l(metadata._filename);

  l(metadata);

  return metadata.title;
}

// getTitle(testUrl);
//
// l(transcribe);

async function main (videoUrl) {
  const filename = await getTitle(videoUrl);
  // l(filename)
  await download(videoUrl, filename);
  // await transcribe(filename);
}

// main();

const example = 'https://www.youtube.com/watch?v=jXVcLVQ4FTg&ab_channel=HighlightHeaven';

// main(example)

module.exports = main;

// getTitle();
//
// download();

================
File: downloading/yt-dlp-download.js
================
const which = require('which');
const spawn = require('child_process').spawn;
const fs = require('fs-extra');
const projectConstants = require('../constants/constants');
const {formatStdErr} = require('../helpers/formatStdErr');

// yt-dlp --no-mtime -f '\''bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best'\''

const l = console.log;
const ytDlpName = process.platform === 'win32' ? 'YoutubeDL' : 'yt-dlp';
const ytDlpPath = which.sync(ytDlpName);

// get data from youtube-dlp stdout string
function extractDataFromString (string) {
  const percentDownloaded = parseInt(string.match(/(\d+\.?\d*)%/)[1]);
  const totalFileSize = string.match(/of\s+(.*?)\s+at/)[1];
  const downloadSpeed = string.match(/at\s+(.*?)\s+ETA/)[1];

  const fileSizeValue = totalFileSize.match(/\d+\.\d+/)[0];
  const fileSizeUnit = totalFileSize.split(fileSizeValue)[1];

  return {
    percentDownloaded,
    totalFileSize,
    downloadSpeed,
    fileSizeUnit,
    fileSizeValue,
  }
}

// delete from transcription array (used to get rid of the yt-dlp process)
function deleteFromGlobalTranscriptionsBasedOnWebsocketNumber (websocketNumber) {
  // check for websocket number and type
  function matchDownloadProcessByWebsocketNumber (transcriptionProcess) {
    return transcriptionProcess.websocketNumber === websocketNumber && transcriptionProcess.type === 'download';
  }

  // TODO should rename this as processes not transcriptions:

  // delete the download process from the processes array
  const transcriptionIndex = global.transcriptions.findIndex(matchDownloadProcessByWebsocketNumber);
  if (transcriptionIndex > -1) { // only splice array when item is found
    global.transcriptions.splice(transcriptionIndex, 1); // 2nd parameter means remove one item only
  }
}


async function downloadFile ({
  videoUrl,
  filepath,
  randomNumber,
  websocketConnection,
  filename,
  websocketNumber
}) {
  return new Promise(async (resolve, reject) => {
    try {

      let latestDownloadInfo = '';

      const startedAtTime = new Date();

      const interval = setInterval(() => {
        l(latestDownloadInfo);

        // only run if ETA is in the string
        if (!latestDownloadInfo.includes('ETA')) return

        const { percentDownloaded, totalFileSize, downloadSpeed, fileSizeUnit, fileSizeValue } = extractDataFromString(latestDownloadInfo);

        websocketConnection.send(JSON.stringify({
          message: 'downloadInfo',
          fileName: filename,
          percentDownloaded,
          totalFileSize,
          downloadSpeed,
          startedAtTime,
          fileSizeUnit,
          fileSizeValue
        }), function () {});

      }, 1000);

      const ytdlProcess = spawn('yt-dlp', [
        videoUrl,
        '--no-mtime',
        '--no-playlist',
        '-f',
        'bestvideo[ext=mp4][height<=720]+bestaudio[ext=m4a]/best[ext=mp4]/best',
        '-o',
        `./uploads/${randomNumber}.%(ext)s`
      ]);

      // add process to global array (for deleting if canceled)
      const process = {
        websocketNumber,
        spawnedProcess: ytdlProcess,
        type: 'download'
      }
      global.transcriptions.push(process)

      ytdlProcess.stdout.on('data', (data) => {
        l(`STDOUT: ${data}`);
        latestDownloadInfo = data.toString();
      })

      ytdlProcess.stderr.on('data', (data) => {
        l(`STDERR: ${data}`);
      });

      ytdlProcess.on('close', (code) => {
        l(`child process exited with code ${code}`);
        clearInterval(interval)
        if (code === 0) {
          resolve();
        } else {
          reject();
        }
        // TODO: this code is bugged
        deleteFromGlobalTranscriptionsBasedOnWebsocketNumber(websocketNumber);
        websocketConnection.send(JSON.stringify({
          message: 'downloadingFinished',
        }), function () {});
      });

    } catch (err) {
      l('error from download')
      l(err);

      reject(err);

      throw new Error(err)
    }

  });
}

async function downloadFileApi ({
  videoUrl,
  filepath,
  randomNumber,
  filename,
  numberToUse
}) {
  return new Promise(async (resolve, reject) => {
    try {

      let latestDownloadInfo = '';
      let currentPercentDownload = 0;

      const startedAtTime = new Date();

      const interval = setInterval(() => {
        l(latestDownloadInfo);

        // only run if ETA is in the string
        if (!latestDownloadInfo.includes('ETA')) return

        const { percentDownloaded, totalFileSize, downloadSpeed, fileSizeUnit, fileSizeValue } = extractDataFromString(latestDownloadInfo);
        currentPercentDownload = percentDownloaded;

      }, 1000);

      const ytdlProcess = spawn('yt-dlp', [
        videoUrl,
        '--no-mtime',
        '--no-playlist',
        '-f',
        'bestvideo[ext=mp4][height<=720]+bestaudio[ext=m4a]/best[ext=mp4]/best',
        '-o',
        `./uploads/${numberToUse}`
      ]);

      ytdlProcess.stdout.on('data', (data) => {
        l(`STDOUT: ${data}`);
        latestDownloadInfo = data.toString();
      })

      ytdlProcess.stderr.on('data', (data) => {
        l(`STDERR: ${data}`);
      });

      ytdlProcess.on('close', (code) => {
        l(`child process exited with code ${code}`);
        clearInterval(interval)
        if (code === 0) {
          resolve();
        } else {
          reject();
        }
      });

    } catch (err) {
      l('error from download')
      l(err);

      reject(err);

      throw new Error(err)
    }

  });
}

// get file title name given youtube url
async function getFilename (videoUrl) {
  return new Promise(async (resolve, reject) => {
    try {

      const ytdlProcess = spawn('yt-dlp', [
        '--get-filename',
        '-f',
        'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
        videoUrl
      ]);

      ytdlProcess.stdout.on('data', (data) => {
        // l(`STDOUTT: ${data}`);
        resolve(data.toString().replace(/\r?\n|\r/g, ''));
      })

      ytdlProcess.stderr.on('data', (data) => {
        // l(`STDERR: ${data}`);
      });

      ytdlProcess.on('close', (code) => {
        l(`child process exited with code ${code}`);
        if (code === 0) {
          resolve();
        } else {
          reject();
        }
      });

    } catch (err) {
      l('error from download')
      l(err);

      reject(err);

      throw new Error(err)
    }

  });

}

const testUrl = 'https://www.youtube.com/watch?v=wnhvanMdx4s';

function generateRandomNumber () {
  return Math.floor(Math.random() * 10000000000).toString();
}

const randomNumber = generateRandomNumber();

async function main () {
  const title = await getFilename(testUrl);
  l(title);
  await downloadFile({
    videoUrl: testUrl,
    randomNumber,
    filepath: `./${title}`
  })
}

// main()

module.exports = {
  downloadFile,
  downloadFileApi,
  getFilename
};

================
File: examples/dnevnik.srt
================
WEBVTT

00:00.000 --> 00:24.860
Dubar den. Â sam Mirela Vasin, a ovo su Vesti dana.

00:24.860 --> 00:34.860
Na jarinju uhapšen Srbin, bivši pripadnik Kosovske policije. Srbi počale da se okupljaju i postavljaju barikade.

00:34.860 --> 00:44.860
Premijerka Anna Brnabić apelovala na Međunarodnu zajednicu da ne okreće glavu od ljudskih prava Srba na kosmetu.

00:44.860 --> 00:52.860
Ukrajina trađi dodatno oružje, Moskva upozorava na posledice.

00:52.860 --> 01:04.860
Danas se igraju dva četvrtfinalna meća na svetskom futbolskom prvenstvu – Marokko-Portugalija i Engleska-Francuska.

================
File: helpers/formatStdErr.js
================
const l = console.log;

const ten = ' 10%|█         | 5332/52135 [00:10<01:25, 545.77frames/s]';

function formatStdErr (stdErrData) {
  // if a progress output
  if (stdErrData.includes('frames/s')) {
    // looks like: '█         '
    const progressBar = stdErrData.split('|')[1].split('|')[0]

    // looks like: '10%'
    let percentDone = stdErrData.split('|')[0].trim();

    // looks like: 10
    let percentDoneAsNumber = Number(stdErrData.split('%')[0].trim());

    // looks like: '00:10<01:25, 545.77frames/s]'
    let timeLeftPortion = stdErrData.split('[')[1].split('[')[0]

    // looks like: '00:10<01:25'
    const firstPortion = timeLeftPortion.split(',')[0]

    // looks like: '00:10'
    const timeElapsed = firstPortion.split('<')[0]

    // looks like: '01:25'
    const timeRemainingString = timeLeftPortion.split('<')[1].split(',')[0]

    // looks like: '545.77'
    const speed = timeLeftPortion.split('<')[1].split(',')[1].split('frames')[0].trim()

    // looks like: '545.77'
    const splitTimeRemaining = timeRemainingString.split(':')

    // looks like: '01'
    const secondsRemaining = Number(splitTimeRemaining.pop());

    // looks like: '25'
    const minutesRemaining = Number(splitTimeRemaining.pop());

    // looks like: 'NaN'
    const hoursRemaining = Number(splitTimeRemaining.pop());

    // format for lib
    return {
      progressBar,
      percentDone,
      timeElapsed,
      speed,
      percentDoneAsNumber,
      timeRemaining: {
        string: timeRemainingString,
        hoursRemaining,
        minutesRemaining,
        secondsRemaining
      },
    }
  } else {
    return false
  }
}

module.exports = {
  formatStdErr
}

================
File: helpers/getLanguageNames.js
================
function shouldTranslateTo (languageName) {
  return translateLanguages.filter(function (filteredLanguage) {
    return languageName === filteredLanguage.name;
  })
}

function shouldTranslateFrom (languageName) {
  return translateLanguages.filter(function (filteredLanguage) {
    return languageName === filteredLanguage.name;
  })
}

================
File: helpers/helpers.js
================
/**
 * Translates seconds into human readable format of seconds, minutes, hours, days, and years
 *
 * @param  {number} seconds The number of seconds to be processed
 * @return {string}         The phrase describing the amount of time
 */
// poor naming -osb910
function forHumans ( seconds ) {
  let levels = [
    [Math.floor(seconds / 31536000), 'years'],
    [Math.floor((seconds % 31536000) / 86400), 'days'],
    [Math.floor(((seconds % 31536000) % 86400) / 3600), 'hours'],
    [Math.floor((((seconds % 31536000) % 86400) % 3600) / 60), 'minutes'],
    [(((seconds % 31536000) % 86400) % 3600) % 60, 'seconds'],
  ];
  let returntext = '';

  for (let i = 0, max = levels.length; i < max; i++) {
    if ( levels[i][0] === 0 ) continue;
    returntext += ' ' + levels[i][0] + ' ' + (levels[i][0] === 1 ? levels[i][1].substr(0, levels[i][1].length-1): levels[i][1]);
  };
  return returntext.trim();
}

function forHumansNoSeconds ( seconds ) {
  let levels = [
    [Math.floor(seconds / 31536000), 'years'],
    [Math.floor((seconds % 31536000) / 86400), 'days'],
    [Math.floor(((seconds % 31536000) % 86400) / 3600), 'hours'],
    [Math.floor((((seconds % 31536000) % 86400) % 3600) / 60), 'minutes'],
  ];
  let returntext = '';

  for (let i = 0, max = levels.length; i < max; i++) {
    if ( levels[i][0] === 0 ) continue;
    returntext += ' ' + levels[i][0] + ' ' + (levels[i][0] === 1 ? levels[i][1].substr(0, levels[i][1].length-1): levels[i][1]);
  };
  return returntext.trim();
}

function forHumansHoursAndMinutes ( seconds ) {
  let levels = [
    [Math.floor(seconds / 3600), 'hours'],
    [Math.floor((seconds % 3600) / 60), 'minutes'],
  ];
  let returntext = '';

  for (let i = 0, max = levels.length; i < max; i++) {
    if ( levels[i][0] === 0 ) continue;
    returntext += ' ' + levels[i][0] + ' ' + (levels[i][0] === 1 ? levels[i][1].substr(0, levels[i][1].length-1): levels[i][1]);
  };
  return returntext.trim();
}



const decrementBySecond = timeRemainingValues => {
  let {secondsRemaining, minutesRemaining, hoursRemaining} = timeRemainingValues;

  if (secondsRemaining == 0) {
    if (minutesRemaining > 0) {
      secondsRemaining = 59;
      minutesRemaining--;
    }
  } else {
    secondsRemaining--;
  }

  if (minutesRemaining == 0) {
    if (hoursRemaining > 0) {
      minutesRemaining = 59;
      hoursRemaining--;
    }
  }

  minutesRemaining = `${minutesRemaining}`.padStart(2, '0');
  secondsRemaining = `${secondsRemaining}`.padStart(2, '0');

  const wholeTime = `${hoursRemaining ? hoursRemaining + ':' : ''}${minutesRemaining}:${secondsRemaining}`;

  return {
    secondsRemaining,
    minutesRemaining,
    hoursRemaining,
    string: wholeTime
  }
}

module.exports = {
  forHumans,
  forHumansNoSeconds,
  decrementBySecond,
  forHumansHoursAndMinutes
}

================
File: lib/convertText.js
================
const fs = require('fs-extra');
const convert = require('cyrillic-to-latin');
const { simplified } = require('zh-convert');

async function convertSerbianCyrillicToLatin ({
  transcribedSrtFilePath,
  transcribedVttFilePath,
  transcribedTxtFilePath,
}) {
  let data = await fs.readFile(transcribedSrtFilePath, 'utf-8');
  let latinCharactersText = convert(data);
  await fs.writeFile(transcribedSrtFilePath, latinCharactersText, 'utf-8');

  data = await fs.readFile(transcribedVttFilePath, 'utf-8');
  latinCharactersText = convert(data);
  await fs.writeFile(transcribedVttFilePath, latinCharactersText, 'utf-8');

  data = await fs.readFile(transcribedTxtFilePath, 'utf-8');
  latinCharactersText = convert(data);
  await fs.writeFile(transcribedTxtFilePath, latinCharactersText, 'utf-8');
}

async function convertChineseTraditionalToSimplified ({
  transcribedSrtFilePath,
  transcribedVttFilePath,
  transcribedTxtFilePath,
}) {
  let data = await fs.readFile(transcribedSrtFilePath, 'utf-8');
  let simplifiedText = simplified(data);
  await fs.writeFile(transcribedSrtFilePath, simplifiedText, 'utf-8');

  data = await fs.readFile(transcribedVttFilePath, 'utf-8');
  simplifiedText = simplified(data);
  await fs.writeFile(transcribedVttFilePath, simplifiedText, 'utf-8');

  data = await fs.readFile(transcribedTxtFilePath, 'utf-8');
  simplifiedText = simplified(data);
  await fs.writeFile(transcribedTxtFilePath, simplifiedText, 'utf-8');
}

module.exports = {
  convertSerbianCyrillicToLatin,
  convertChineseTraditionalToSimplified,
}

================
File: lib/files.js
================
const filenamify = require('filenamify');
const fs = require('fs-extra');
const moment = require('moment/moment');

const makeFileNameSafe = function (string) {
  return filenamify(string, {replacement: '_' })
    .replace(/[&\/\\#,+()$~%.'":*?<>{}!]/g, '')
    .replace(/\s+/g,'_')
    .split('：').join(':');
}

function decode_utf8 (s) {
  return decodeURIComponent(escape(s));
}

// it's an array of file names
const getAllDirectories = async (dir) => {
  let files = await fs.promises.readdir(dir, { withFileTypes: true });

  let newFiles = [];

  for (let file of files) {
    // l('file');
    // l(file);
    // l(file.name);
    // l(file.isDirectory());
    if (!file.isDirectory()) continue;

    let processingData;
    try {
      processingData = JSON.parse(await fs.readFile(`${dir}/${file.name}/processing_data.json`, 'utf8'));
    } catch (err) {
      // l('err');
      // l(err);
      processingData = null;
    }
    //
    // l('processing data');
    // l(processingData);

    if (processingData && processingData.startedAt && processingData.uploadDurationInSeconds) {
      newFiles.push({
        name: file.name,
        processingData,
        formattedDate: moment(processingData.startedAt).format('D MMM YYYY'),
        timestamp: processingData.startedAt && new Date(processingData.startedAt).getTime()
      });
    }
  }

  return newFiles
}

async function sortByModifiedAtTime (dir) {
  // sort by modified date
  return files
    .map(async fileName => ({
      name: fileName,
      time: await fs.stat(`${dir}/${fileName}`).mtime.getTime(),
    }))
    .sort((a, b) => a.time - b.time)
    .map(file => file.name);
}

async function getMatchingFiles ({ files, language, keepMedia }) {
  // TODO: ugly design but can't think of a better approach atm
  let keepMediaMatch;
  if (keepMedia === false) {
    keepMediaMatch = undefined;
  } else {
    keepMediaMatch = keepMedia;
  }

  if (language) {
    files = files.filter((file) => {
      return file.processingData.language === language;
    });
  }

  if (keepMediaMatch !== undefined) {
    files = files.filter((file) => {
      return file.processingData.keepMedia === keepMediaMatch;
    });
  }

  return files;
}

module.exports = {
  makeFileNameSafe,
  decode_utf8,
  getAllDirectories,
  sortByModifiedAtTime,
  getMatchingFiles
}

================
File: lib/stats.js
================
// one minute in milliseconds
const fs = require('fs-extra');
const {forHumansHoursAndMinutes} = require('../helpers/helpers');
const oneMinute = 1000 * 60;

const interval = oneMinute;

global.siteStats = {}

const existingTranscriptions = 0;
const existingSecondsTranscribed = 0;

async function getTranscriptionData () {
  let totalSeconds = 0;

  const processDirectory = process.cwd();
  const transcriptionsDirectory = `${processDirectory}/transcriptions`;
  await fs.mkdirp(transcriptionsDirectory);

  const transcriptionsDirectoryContents = await fs.readdir(transcriptionsDirectory);

  // loop through all transcription directories
  for (const transcriptionDirectory of transcriptionsDirectoryContents) {
    // check if directory is directory
    const directoryPath = `${transcriptionsDirectory}/${transcriptionDirectory}`;

    // this is guaranteed to exist
    const directoryStats = await fs.stat(directoryPath);

    const isDirectory = directoryStats.isDirectory();

    // only loop through if it's a directory
    if (isDirectory) {
      // check if directory has a processing_data.json file
      const processingDataPath = `${directoryPath}/processing_data.json`;

      // read processing_data.json file
      // dont error if processingData doesn't exist
      const processingDataExists = await fs.pathExists(processingDataPath);

      if (!processingDataExists) {
        continue
      }

      let processingData, fileExistsButJsonError;
      try {
        processingData = JSON.parse(await fs.readFile(processingDataPath, 'utf8'));
      } catch (err) {

        // syntax error
        fileExistsButJsonError = err.toString().includes('SyntaxError');

        // delete the media if json error
        if (fileExistsButJsonError) {
          continue
        }
      }

      if (!processingData) {
        continue
      }

      const uploadDurationInSeconds = processingData.uploadDurationInSeconds;

      if (uploadDurationInSeconds) {
        totalSeconds += uploadDurationInSeconds;
      }


    }
  }

  totalSeconds = totalSeconds + existingSecondsTranscribed;

  global.siteStats = {
    totalSeconds: totalSeconds,
    amountOfTranscriptions: transcriptionsDirectoryContents.length + existingTranscriptions,
    humanReadableTime: forHumansHoursAndMinutes(totalSeconds),
  }

  l('siteStats');
  l(global.siteStats);
}

// run immediately on boot
getTranscriptionData();

// Schedule the directory reading operation at regular intervals
setInterval(async () => {
  getTranscriptionData();
}, interval);

================
File: lib/transcribing.js
================
const fs = require('fs-extra');
const {autoDetectLanguage} = require('../transcribe/transcribing');
const {formatStdErr} = require('../helpers/formatStdErr');
const { getLanguageCodeForAllLanguages } = require('../constants/constants');
const filenamify = require('filenamify');
const path = require('path');

async function writeToProcessingDataFile (processingDataPath, dataObject) {
  // save data to the file
  const processingDataExists = await fs.exists(processingDataPath)

  l('processingDataExists')
  l(processingDataExists);
  if (processingDataExists) {
    const fileData = await fs.readFile(processingDataPath, 'utf8')
    l('fileData');
    l(fileData);

    const existingProcessingData = JSON.parse(fileData);

    let merged = Object.assign({}, existingProcessingData, dataObject);

    l('merged');
    l(merged);

    await fs.writeFile(processingDataPath, JSON.stringify(merged), 'utf8');
  } else {
    await fs.writeFile(processingDataPath, JSON.stringify(dataObject), 'utf8');
  }
}

function detectLanguageFromString (dataAsString) {
  if (!dataAsString) return false
  if (dataAsString.includes('Detected language:')) {
    // parse out the language from the console output
    return dataAsString.split(':')[1].substring(1).trimEnd();
  }
  return false;
}

function handleStdOut (data) {
  l(`STDOUT: ${data}`)

  // save auto-detected language
  const parsedLanguage = autoDetectLanguage(data.toString());
  return parsedLanguage
}

// print the latest progress and save it to the processing data file
function handleStdErr ({
 model, language, originalFileName, processingDataPath
}) {
  return function (data) {
    (async function () {
      l(`STDERR: ${data}`)

      // get value from the whisper output string
      const formattedProgress = formatStdErr(data.toString());
      l('formattedProgress');
      l(formattedProgress);

      const { percentDoneAsNumber, percentDone, speed, timeRemaining  } = formattedProgress;

      // TODO: add speed here and timeremaining

      // save info to processing_data.json
      await writeToProcessingDataFile(processingDataPath, {
        progress: percentDoneAsNumber,
        status: 'processing',
        model,
        language,
        languageCode: getLanguageCodeForAllLanguages(language),
        originalFileName
      })

    })()
  }
}

const outputFileExtensions = ['.srt', '.vtt', '.txt']

// rename files to proper names for api (remove file extension)
async function moveFiles (randomNumber, fileExtension) {
  const holderFolder = `${process.cwd()}/transcriptions/${randomNumber}`;
  for (const extension of outputFileExtensions) {
    const oldLocation = `${holderFolder}/${randomNumber}.${fileExtension}${extension}`
    await fs.move(oldLocation, `${holderFolder}/${randomNumber}${extension}`)
  }
}

// when whisper process finishes
function handleProcessClose ({ processingDataPath, originalUpload, numberToUse }) {
  return function (code) {
    (async function () {
      l(`PROCESS FINISHED WITH CODE: ${code}`)

      const processFinishedSuccessfullyBasedOnStatusCode = code === 0;

      // if process failed
      if (!processFinishedSuccessfullyBasedOnStatusCode) {
        // if process errored out
        await writeToProcessingDataFile(processingDataPath, {
          status: 'error',
          error: 'whisper process failed'
        })

        // throw error if failed
        throw new Error('Whisper process did not exit successfully');
      } else {
        // // TODO: pass file extension to this function
        // const fileExtension = originalUpload.split('.').pop();
        //
        // // rename whisper created files
        // await moveFiles(numberToUse, fileExtension)

        // save mark upload as completed transcribing
        await writeToProcessingDataFile(processingDataPath, {
          status: 'completed',
        })

      }
    })()
  }
}

// example file from multer
// {
//   fieldname: 'file',
//   originalname: 'dutch_language.mp3',
//   encoding: '7bit',
//   mimetype: 'audio/mpeg',
//   destination: './uploads/',
//   filename: '572fa0ecb660b1d0eb489b879c2e2310',
//   path: 'uploads/572fa0ecb660b1d0eb489b879c2e2310',
//   size: 22904865
// }

// make sure the file name is safe for the file system
const makeFileNameSafe = function (string) {
  return filenamify(string, {replacement: '_' }) // replace all non-URL-safe characters with an underscore
    .split('：').join(':') // replace chinese colon with english colon
    .replace(/[&\/\\#,+()$~%.'":*?<>{}!]/g, '') // remove special characters
    .replace(/\s+/g,'_') // replace spaces with underscores
}

//
function createFileNames (originalFileName) {
  // name of file without extension
  const originalFileNameWithoutExtension = path.parse(originalFileName).name;

  return {
    originalFileNameWithExtension: originalFileName, // original file name
    originalFileExtension: path.parse(originalFileName).ext, // file extension
    originalFileNameWithoutExtension, // file name with extension removed
    directorySafeFileNameWithoutExtension: makeFileNameSafe(originalFileNameWithoutExtension), // safe file name for directory name
  }
}

module.exports = {
  // handle processing data file
  writeToProcessingDataFile,

  detectLanguageFromString,

  // handle output from the whisper process
  handleStdOut,
  handleStdErr,
  handleProcessClose,

  // file name helpers
  makeFileNameSafe,
  createFileNames
}

================
File: lib/websockets.js
================
const WebSocket = require('ws');
const WebSocketServer = WebSocket.WebSocketServer;
const { getQueueInformationByWebsocketNumber } = require('../queue/newQueue');
const { updateQueueItemStatus } = require('../queue/queue');

function deleteFromGlobalTranscriptionsBasedOnWebsocketNumber (websocketNumber) {
  // find transcription based on websocketNumber
  const closerTranscription = global['transcriptions'].find(function (transcription) {
    return transcription.websocketNumber === websocketNumber;
  })

  //
  const transcriptionIndex = global.transcriptions.indexOf(closerTranscription);

  // only splice array when item is found
  if (transcriptionIndex > -1) {
    // 2nd parameter means remove one item only
    global.transcriptions.splice(transcriptionIndex, 1);
  }
}


/** when websocket disconnects **/
function deleteWebsocketAndEndProcesses ({ websocketNumber, websocketConnection, websocket, index }) {
  l(`Disconnected user found: ${websocketNumber}`);

  function matchByWebsocketNumber (item) {
    return item.websocketNumber === websocketNumber;
  }

  // disconnect websocket and delete from global holder
  websocketConnection.terminate();
  global.webSocketData.splice(index, 1);
  l(`${websocketNumber} Deleted from global.webSocketData`);

  // find transcription based on websocketNumber
  const foundProcess = global.transcriptions.find(matchByWebsocketNumber)

  const existingProcess = foundProcess && foundProcess.spawnedProcess;

  // kill the process
  if (existingProcess) {

    // TODO: save processing info and conditionally kill

    // kill spawned process
    foundProcess.spawnedProcess.kill('SIGINT');
    l(`Found and killed process: ${websocketNumber}`);

    // delete from transcription array
    const transcriptionIndex = global.transcriptions.findIndex(matchByWebsocketNumber);

    // only splice array when item is found
    if (index > -1) {
      global.transcriptions.splice(transcriptionIndex, 1); // 2nd parameter means remove one item only
    }
  }

  // delete from queue
  const queueIndex = global.newQueue.findIndex(matchByWebsocketNumber);

  // only splice array when item is found
  if (queueIndex > -1) {

    // 2nd parameter means remove one item only
    global.newQueue.splice(queueIndex, 1);

    l(`${websocketNumber} Deleted from global.newQueue`);
  }

  // only updates if not marked as completed
  updateQueueItemStatus(websocketNumber, 'abandoned');

  // inform every websocket that is in the queue of their updated queue position
  sendOutQueuePositionUpdate();
}

/**
 * find queue information for each websocket and send it (if they're in the queue)
 */
function sendOutQueuePositionUpdate () {
  // loop through websockets and tell them one less is processing
  for (let [, websocket] of global.webSocketData.entries() ) {
    // the actual websocket
    // l(websocket.websocketNumber)
    const websocketConnection = websocket.websocket;
    const websocketNumber = websocket.websocketNumber;

    if (websocketConnection.readyState === WebSocket.OPEN) {

      const { queuePosition } = getQueueInformationByWebsocketNumber(websocketNumber);

      // l('queuePosition');
      // l(queuePosition);

      if (queuePosition) {
        websocketConnection.send(JSON.stringify({
          message: 'queue',
          placeInQueue: queuePosition
        }), function () {});
      }
    }
  }
}

/**
 * check for websockets that haven't marked themselves as alive
**/
function checkForDeath () {
  // tell console how many are connected
  const totalAmountOfWebsockets = global.webSocketData.length;
  l(`Disconnect Check for ${totalAmountOfWebsockets}`);

  // loop through array of objects of websockets
  for (let [index, websocket] of global['webSocketData'].entries() ) {
    // the actual websocket
    // l(websocket.websocketNumber)
    const websocketNumber = websocket.websocketNumber
    const websocketConnection = websocket.websocket;

    /** DEAD WEBSOCKET FUNCTIONALITY **/
    // destroy killed websockets and cancel their transcriptions
    if (websocketConnection.isAlive === false) {
      deleteWebsocketAndEndProcesses({ websocketNumber, websocketConnection, websocket, index });
    }

    /** TEST FOR ALIVENESS */
    // mark them as dead, but then check immediately after for redemption chance
    websocketConnection.isAlive = false;
    // trigger their pong event
    websocketConnection.ping();
  }
}

// run on first connection
function setupWebsocket (websocketConnection, request) {
  // random number generated from the frontend (last part of the hit url)
  const websocketNumber = request.url.split('/')[1];

  // TODO: handle case that it's info websocket push



  // add to global array of websockets
  global.webSocketData.push({
    websocketNumber,
    websocket: websocketConnection,
    status: 'alive',
  })

  // chart that it exists for first time (add to global.ws)
  websocketConnection.isAlive = true;

  // send websocket number back to parent function
  return websocketNumber;
}

// called from app.js
function createWebSocketServer (server) {

  // create websocket server
  const wss = new WebSocketServer({ server });

  // instantiate global array of websocket connections
  global.webSocketData = []

  // when a user hits the websocket server
  wss.on('connection', function (websocketConnection, request, client) {

    // add to websocketQueue, and mark as alive
    const websocketNumber = setupWebsocket(websocketConnection, request);

    l(`websocket connected: ${websocketNumber}`);

    // server sets all websockets as dead, but then checks for life, set for true if alive
    websocketConnection.on('pong', () => websocketConnection.isAlive = true )

    // log when user connects / disconnect
    websocketConnection.on('close', () => {
      l('websocket connection')
      // l(websocketConnection)
      l(`websocket closed: ${websocketNumber}`)
      // websocketConnection.isAlive = false
      // checkForDeath();
    });
  });

  // check every 5 seconds for dead sockets (still takes 10s)
  setInterval(checkForDeath, 1000 * 5);
}

module.exports = {
  createWebSocketServer,
  sendOutQueuePositionUpdate,
};

================
File: public/javascripts/circle-progress.min.js
================
/*!
 * Circle Progress - v0.2.4 - 2022-05-16
 * https://tigrr.github.io/circle-progress/
 * Copyright (c) Tigran Sargsyan
 * Licensed MIT
 */

"use strict";function ownKeys(e,t){var r,n=Object.keys(e);return Object.getOwnPropertySymbols&&(r=Object.getOwnPropertySymbols(e),t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)),n}function _objectSpread(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?ownKeys(Object(r),!0).forEach(function(t){_defineProperty(e,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):ownKeys(Object(r)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))})}return e}function _defineProperty(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _defineProperties(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function _createClass(t,e,r){return e&&_defineProperties(t.prototype,e),r&&_defineProperties(t,r),t}function _typeof(t){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}!function(t,e){"function"==typeof define&&define.amd?define([],e):"object"===("undefined"==typeof module?"undefined":_typeof(module))&&module.exports?module.exports=e():t.CircleProgress=e()}("undefined"!=typeof self?self:void 0,function(){!function(){try{if("undefined"==typeof SVGElement||Boolean(SVGElement.prototype.innerHTML))return}catch(t){return}function r(t){switch(t.nodeType){case 1:return function(t){var e="";e+="<"+t.tagName,t.hasAttributes()&&[].forEach.call(t.attributes,function(t){e+=" "+t.name+'="'+t.value+'"'});e+=">",t.hasChildNodes()&&[].forEach.call(t.childNodes,function(t){e+=r(t)});return e+="</"+t.tagName+">"}(t);case 3:return t.textContent.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");case 8:return"\x3c!--"+t.nodeValue+"--\x3e"}}Object.defineProperty(SVGElement.prototype,"innerHTML",{get:function(){var e="";return[].forEach.call(this.childNodes,function(t){e+=r(t)}),e},set:function(t){for(;this.firstChild;)this.removeChild(this.firstChild);try{var e=new DOMParser;e.async=!1;var r="<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>"+t+"</svg>",n=e.parseFromString(r,"text/xml").documentElement;[].forEach.call(n.childNodes,function(t){this.appendChild(this.ownerDocument.importNode(t,!0))}.bind(this))}catch(t){throw new Error("Error parsing markup string")}}}),Object.defineProperty(SVGElement.prototype,"innerSVG",{get:function(){return this.innerHTML},set:function(t){this.innerHTML=t}})}();function h(t,n,i,a,s){var o,u="string"==typeof t?h.easings[t]:t;requestAnimationFrame(function t(e){e-=o=o||e,e=Math.min(e,a);var r=u(e,n,i,a);s(r),e<a?requestAnimationFrame(t):s(n+i)})}var t,s,a,o,l,e,i=(t=function(t,e,r,n){var i,a;if(n=n||document,a=Object.create(s),"string"==typeof t&&(t=n.querySelector(t)),t)return(i=n.createElementNS("http://www.w3.org/2000/svg","svg")).setAttribute("version","1.1"),e&&i.setAttribute("width",e),r&&i.setAttribute("height",r),e&&r&&i.setAttribute("viewBox","0 0 "+e+" "+r),t.appendChild(i),a.svg=i,a},s={element:function(t,e,r,n){var i=a(this,t,e,n);return r&&(i.el.innerHTML=r),i}},a=function(t,e,r,n,i){var a;return i=i||document,(a=Object.create(o)).el=i.createElementNS("http://www.w3.org/2000/svg",e),a.attr(r),(n?n.el||n:t.svg).appendChild(a.el),a},o={attr:function(t,e){if(void 0===t)return this;if("object"!==_typeof(t))return void 0===e?this.el.getAttributeNS(null,t):(this.el.setAttribute(t,e),this);for(var r in t)this.attr(r,t[r]);return this},content:function(t){return this.el.innerHTML=t,this}},t);return h.easings={linear:function(t,e,r,n){return r*t/n+e},easeInQuad:function(t,e,r,n){return r*(t/=n)*t+e},easeOutQuad:function(t,e,r,n){return-r*(t/=n)*(t-2)+e},easeInOutQuad:function(t,e,r,n){return(t/=n/2)<1?r/2*t*t+e:-r/2*(--t*(t-2)-1)+e},easeInCubic:function(t,e,r,n){return r*(t/=n)*t*t+e},easeOutCubic:function(t,e,r,n){return t/=n,r*(--t*t*t+1)+e},easeInOutCubic:function(t,e,r,n){return(t/=n/2)<1?r/2*t*t*t+e:r/2*((t-=2)*t*t+2)+e},easeInQuart:function(t,e,r,n){return r*(t/=n)*t*t*t+e},easeOutQuart:function(t,e,r,n){return t/=n,-r*(--t*t*t*t-1)+e},easeInOutQuart:function(t,e,r,n){return(t/=n/2)<1?r/2*t*t*t*t+e:-r/2*((t-=2)*t*t*t-2)+e},easeInQuint:function(t,e,r,n){return r*(t/=n)*t*t*t*t+e},easeOutQuint:function(t,e,r,n){return t/=n,r*(--t*t*t*t*t+1)+e},easeInOutQuint:function(t,e,r,n){return(t/=n/2)<1?r/2*t*t*t*t*t+e:r/2*((t-=2)*t*t*t*t+2)+e},easeInSine:function(t,e,r,n){return-r*Math.cos(t/n*(Math.PI/2))+r+e},easeOutSine:function(t,e,r,n){return r*Math.sin(t/n*(Math.PI/2))+e},easeInOutSine:function(t,e,r,n){return-r/2*(Math.cos(Math.PI*t/n)-1)+e},easeInExpo:function(t,e,r,n){return r*Math.pow(2,10*(t/n-1))+e},easeOutExpo:function(t,e,r,n){return r*(1-Math.pow(2,-10*t/n))+e},easeInOutExpo:function(t,e,r,n){return(t/=n/2)<1?r/2*Math.pow(2,10*(t-1))+e:(t--,r/2*(2-Math.pow(2,-10*t))+e)},easeInCirc:function(t,e,r,n){return t/=n,-r*(Math.sqrt(1-t*t)-1)+e},easeOutCirc:function(t,e,r,n){return t/=n,t--,r*Math.sqrt(1-t*t)+e},easeInOutCirc:function(t,e,r,n){return(t/=n/2)<1?-r/2*(Math.sqrt(1-t*t)-1)+e:(t-=2,r/2*(Math.sqrt(1-t*t)+1)+e)}},l={polarToCartesian:function(t,e){return{x:t*Math.cos(e*Math.PI/180),y:t*Math.sin(e*Math.PI/180)}}},(e=function(){function s(t){var e,r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:document;if(_classCallCheck(this,s),"string"==typeof t&&(t=n.querySelector(t)),!t)throw new Error("CircleProgress: you must pass the container element as the first argument");if(t.circleProgress)return t.circleProgress;(t.circleProgress=this).doc=n,t.setAttribute("role","progressbar"),this.el=t,r=_objectSpread(_objectSpread({},s.defaults),r),Object.defineProperty(this,"_attrs",{value:{},enumerable:!1}),e="valueOnCircle"===r.textFormat?16:8,this.graph={paper:i(t,100,100),value:0},this.graph.paper.svg.setAttribute("class","circle-progress"),this.graph.circle=this.graph.paper.element("circle").attr({class:"circle-progress-circle",cx:50,cy:50,r:50-e/2,fill:"none",stroke:"#ddd","stroke-width":e}),this.graph.sector=this.graph.paper.element("path").attr({d:s._makeSectorPath(50,50,50-e/2,0,0),class:"circle-progress-value",fill:"none",stroke:"#00E699","stroke-width":e}),this.graph.text=this.graph.paper.element("text",{class:"circle-progress-text",x:50,y:50,font:"16px Arial, sans-serif","text-anchor":"middle",fill:"#999"}),this._initText(),this.attr(["indeterminateText","textFormat","startAngle","clockwise","animation","animationDuration","constrain","min","max","value"].filter(function(t){return t in r}).map(function(t){return[t,r[t]]}))}return _createClass(s,[{key:"value",get:function(){return this._attrs.value},set:function(t){this.attr("value",t)}},{key:"min",get:function(){return this._attrs.min},set:function(t){this.attr("min",t)}},{key:"max",get:function(){return this._attrs.max},set:function(t){this.attr("max",t)}},{key:"startAngle",get:function(){return this._attrs.startAngle},set:function(t){this.attr("startAngle",t)}},{key:"clockwise",get:function(){return this._attrs.clockwise},set:function(t){this.attr("clockwise",t)}},{key:"constrain",get:function(){return this._attrs.constrain},set:function(t){this.attr("constrain",t)}},{key:"indeterminateText",get:function(){return this._attrs.indeterminateText},set:function(t){this.attr("indeterminateText",t)}},{key:"textFormat",get:function(){return this._attrs.textFormat},set:function(t){this.attr("textFormat",t)}},{key:"animation",get:function(){return this._attrs.animation},set:function(t){this.attr("animation",t)}},{key:"animationDuration",get:function(){return this._attrs.animationDuration},set:function(t){this.attr("animationDuration",t)}}]),_createClass(s,[{key:"attr",value:function(e,t){var r=this;if("string"==typeof e)return 1===arguments.length?this._attrs[e]:(this._set(arguments[0],t),this._updateGraph(),this);if("object"!==_typeof(e))throw new TypeError('Wrong argument passed to attr. Expected object, got "'.concat(_typeof(e),'"'));return Array.isArray(e)||(e=Object.keys(e).map(function(t){return[t,e[t]]})),e.forEach(function(t){return r._set(t[0],t[1])}),this._updateGraph(),this}},{key:"_set",value:function(t,e){var r,n={value:"aria-valuenow",min:"aria-valuemin",max:"aria-valuemax"};if(void 0===(e=this._formatValue(t,e)))throw new TypeError("Failed to set the ".concat(t," property on CircleProgress: The provided value is non-finite."));this._attrs[t]!==e&&("min"===t&&e>=this.max||"max"===t&&e<=this.min||("value"===t&&void 0!==e&&this.constrain&&(null!=this.min&&e<this.min&&(e=this.min),null!=this.max&&e>this.max&&(e=this.max)),this._attrs[t]=e,t in n&&(void 0!==e?this.el.setAttribute(n[t],e):this.el.removeAttribute(n[t])),-1!==["min","max","constrain"].indexOf(t)&&(this.value>this.max||this.value<this.min)&&(this.value=Math.min(this.max,Math.max(this.min,this.value))),"textFormat"===t&&(this._initText(),r="valueOnCircle"===e?16:8,this.graph.sector.attr("stroke-width",r),this.graph.circle.attr("stroke-width",r))))}},{key:"_formatValue",value:function(t,e){switch(t){case"value":case"min":case"max":e=parseFloat(e),isFinite(e)||(e=void 0);break;case"startAngle":e=parseFloat(e),e=isFinite(e)?Math.max(0,Math.min(360,e)):void 0;break;case"clockwise":case"constrain":e=!!e;break;case"indeterminateText":e=""+e;break;case"textFormat":if("function"!=typeof e&&-1===["valueOnCircle","horizontal","vertical","percent","value","none"].indexOf(e))throw new Error('Failed to set the "textFormat" property on CircleProgress: the provided value "'.concat(e,'" is not a legal textFormat identifier.'));break;case"animation":if("string"!=typeof e&&"function"!=typeof e)throw new TypeError('Failed to set "animation" property on CircleProgress: the value must be either string or function, '.concat(_typeof(e)," passed."));if("string"==typeof e&&"none"!==e&&!h.easings[e])throw new Error('Failed to set "animation" on CircleProgress: the provided value '.concat(e," is not a legal easing function name."))}return e}},{key:"_valueToAngle",value:function(t){var e=0<arguments.length&&void 0!==t?t:this.value;return Math.min(360,Math.max(0,(e-this.min)/(this.max-this.min)*360))}},{key:"_isIndeterminate",value:function(){return!("number"==typeof this.value&&"number"==typeof this.max&&"number"==typeof this.min)}},{key:"_positionValueText",value:function(t,e){var r=l.polarToCartesian(e,t);this.graph.textVal.attr({x:50+r.x,y:50+r.y})}},{key:"_initText",value:function(){switch(this.graph.text.content(""),this.textFormat){case"valueOnCircle":this.graph.textVal=this.graph.paper.element("tspan",{x:0,y:0,dy:"0.4em",class:"circle-progress-text-value","font-size":"12",fill:"valueOnCircle"===this.textFormat?"#fff":"#888"},"",this.graph.text),this.graph.textMax=this.graph.paper.element("tspan",{x:50,y:50,class:"circle-progress-text-max","font-size":"22","font-weight":"bold",fill:"#ddd"},"",this.graph.text),this.graph.text.el.hasAttribute("dominant-baseline")||this.graph.textMax.attr("dy","0.4em");break;case"horizontal":this.graph.textVal=this.graph.paper.element("tspan",{class:"circle-progress-text-value"},"",this.graph.text),this.graph.textSeparator=this.graph.paper.element("tspan",{class:"circle-progress-text-separator"},"/",this.graph.text),this.graph.textMax=this.graph.paper.element("tspan",{class:"circle-progress-text-max"},"",this.graph.text);break;case"vertical":this.graph.text.el.hasAttribute("dominant-baseline")&&this.graph.text.attr("dominant-baseline","text-after-edge"),this.graph.textVal=this.graph.paper.element("tspan",{class:"circle-progress-text-value",x:50,dy:"-0.2em"},"",this.graph.text),this.graph.textSeparator=this.graph.paper.element("tspan",{class:"circle-progress-text-separator",x:50,dy:"0.1em","font-family":"Arial, sans-serif"},"___",this.graph.text),this.graph.textMax=this.graph.paper.element("tspan",{class:"circle-progress-text-max",x:50,dy:"1.2em"},"",this.graph.text)}"vertical"!==this.textFormat&&(this.graph.text.el.hasAttribute("dominant-baseline")?this.graph.text.attr("dominant-baseline","central"):this.graph.text.attr("dy","0.4em"))}},{key:"_updateGraph",value:function(){var e,r,n=this,i=this.startAngle-90,a=this._getRadius();this._isIndeterminate()?this._updateText(this.value,i,a):(e=this.clockwise,r=this._valueToAngle(),this.graph.circle.attr("r",a),"none"!==this.animation&&this.value!==this.graph.value?h(this.animation,this.graph.value,this.value-this.graph.value,this.animationDuration,function(t){n._updateText(Math.round(t),(2*i+r)/2,a),r=n._valueToAngle(t),n.graph.sector.attr("d",s._makeSectorPath(50,50,a,i,r,e))}):(this.graph.sector.attr("d",s._makeSectorPath(50,50,a,i,r,e)),this._updateText(this.value,(2*i+r)/2,a)),this.graph.value=this.value)}},{key:"_updateText",value:function(t,e,r){"function"==typeof this.textFormat?this.graph.text.content(this.textFormat(t,this.max)):"value"===this.textFormat?this.graph.text.el.textContent=void 0!==t?t:this.indeterminateText:"percent"===this.textFormat?this.graph.text.el.textContent=(void 0!==t&&null!=this.max?Math.round(t/this.max*100):this.indeterminateText)+"%":"none"===this.textFormat?this.graph.text.el.textContent="":(this.graph.textVal.el.textContent=void 0!==t?t:this.indeterminateText,this.graph.textMax.el.textContent=void 0!==this.max?this.max:this.indeterminateText),"valueOnCircle"===this.textFormat&&this._positionValueText(e,r)}},{key:"_getRadius",value:function(){return 50-Math.max(parseFloat(this.doc.defaultView.getComputedStyle(this.graph.circle.el,null)["stroke-width"]),parseFloat(this.doc.defaultView.getComputedStyle(this.graph.sector.el,null)["stroke-width"]))/2}}],[{key:"_makeSectorPath",value:function(t,e,r,n,i,a){0<i&&i<.3?i=0:359.999<i&&(i=359.999);var s=n+i*(2*(a=!!a)-1),o=l.polarToCartesian(r,n),u=l.polarToCartesian(r,s),h=t+o.x,c=t+u.x;return["M",h,e+o.y,"A",r,r,0,+(180<i),+a,c,e+u.y].join(" ")}}]),s}()).defaults={startAngle:0,min:0,max:1,constrain:!0,indeterminateText:"?",clockwise:!0,textFormat:"horizontal",animation:"easeInOutCubic",animationDuration:600},e});

================
File: public/stylesheets/style.css
================
body {
  padding: 50px;
  font: 14px "Lucida Grande", Helvetica, Arial, sans-serif;
}

a {
  color: #00B7FF;
}

================
File: public/robots.txt
================
User-agent: *

================
File: queue/newQueue.js
================
const transcribeWrapped = require('../transcribe/transcribe-wrapped');
// const { sendOutQueuePositionUpdate } = require('../lib/websockets');
const WebSocket = require('ws');

const l = console.log;

const maxConcurrentJobs = Number(process.env.CONCURRENT_AMOUNT);

// create set of numbers from x, such as 1,2,3
function createNumberSet (x) {
  return Array.from({length: x}, (_, i) => i + 1);
}

l('maxConcurrentJobs');
l(maxConcurrentJobs);
const numberSet = createNumberSet(maxConcurrentJobs);

global.jobProcesses = {};

for (const number of numberSet) {
  global.jobProcesses[number] = undefined;
}

l(global.jobProcesses);

// find process number of job to clear it when done
function findProcessNumber (websocketNumber) {
  for (let processNumber in global.jobProcesses) {

    const hasOwnProperty = global.jobProcesses.hasOwnProperty(processNumber)

    if (hasOwnProperty) {

      const matchesByWebsocket = global.jobProcesses[processNumber]?.websocketNumber === websocketNumber;
      if (matchesByWebsocket) {
        return processNumber
      }
    }
  }

  return false

  // TODO: throw an error here?
}
function sendOutQueuePositionUpdate () {
  // loop through websockets and tell them one less is processing
  for (let [, websocket] of global['webSocketData'].entries() ) {
    // the actual websocket
    // l(websocket.websocketNumber)
    const websocketConnection = websocket.websocket;
    const websocketNumber = websocket.websocketNumber;

    if (websocketConnection.readyState === WebSocket.OPEN) {

      const { queuePosition } = getQueueInformationByWebsocketNumber(websocketNumber);

      // l('queuePosition');
      // l(queuePosition);

      if (queuePosition) {
        websocketConnection.send(JSON.stringify({
          message: 'queue',
          placeInQueue: queuePosition
        }), function () {});
      }

      // // TODO: send queue messages here
      // websocketConnection.send(JSON.stringify('finishedProcessing'));
    }
  }
}


// run transcribe job and remove from queue and run next queue item if available
async function runJob (jobObject) {
  const { websocketNumber } = jobObject;

  // simulate job running
  try {
    await transcribeWrapped(jobObject);

    l('job done');

  } catch (err) {
    l('error from runjob');
    l(err);
  }

  const processNumber = findProcessNumber(websocketNumber);
  l('processNumber');
  l(processNumber);

  // run the next item from the queue
  if (global.newQueue.length) {
    const nextQueueItem = global.newQueue.shift();

    nextQueueItem.processNumber = Number(processNumber);

    global.jobProcesses[processNumber] = nextQueueItem;

    // TODO: add got out of queue time here
    runJob(nextQueueItem);
  } else {
    global.jobProcesses[processNumber] = undefined;
  }
}

global.newQueue = [];

// add job to process if available otherwise add to queue
function addToJobProcessOrQueue (jobObject) {
  const { websocketNumber, skipToFront } = jobObject;

  l('skipToFront');
  l(skipToFront);

  // put job on process if there is an available process
  for (let processNumber in global.jobProcesses) {
    const propValue = global.jobProcesses[processNumber];

    if (propValue === undefined) {
      jobObject.processNumber = Number(processNumber);

      global.jobProcesses[processNumber] = jobObject;
      runJob(jobObject);
      return
    }
  }

  // TODO: add got in queue time here

  // push to newQueue if all processes are busy
  if (skipToFront) {
    // last skip to front item
    const lastItem = global.newQueue.filter(queueItem => queueItem.skipToFront === true).slice(-1)[0];

    // insert after latest skipToFront
    if (lastItem) {
      const lastItemIndex = global.newQueue.indexOf(lastItem);

      // insert after last item with skipToFront
      global.newQueue.splice(lastItemIndex + 1, 0, jobObject);
    } else {
      // insert at beginning
      global.newQueue.unshift(jobObject);
    }

  } else {
    // insert at end
    global.newQueue.push(jobObject);
  }

  sendOutQueuePositionUpdate();
}

// get amount of running jobs (used to calculate queue position)
function amountOfRunningJobs () {
  let amount = 0;
  for (let processNumber in global.jobProcesses) {
    const propValue = global.jobProcesses[processNumber];

    if (propValue !== undefined) {
      amount++;
    }
  }

  return amount;
}

// get position in queue based on websocketNumber
function getQueueInformationByWebsocketNumber (websocketNumber) {
  for (const [index, queueItem] of global.newQueue.entries()) {
    if (queueItem.websocketNumber === websocketNumber) {
      return {
        queuePosition: index + 1, // 1
        queueLength: global.newQueue.length, // 4
        aheadOfYou: index,
        behindYou: global.newQueue.length - index - 1
      }
    }
  }
  return false
}

module.exports = {
  addToJobProcessOrQueue,
  amountOfRunningJobs,
  getQueueInformationByWebsocketNumber
}

// function main(){
//   addToJobProcessOrQueue({websocketNumber: 0, skipToFront: false});
//   addToJobProcessOrQueue({websocketNumber: 1, skipToFront: true});
//   addToJobProcessOrQueue({websocketNumber: 2, skipToFront: false});
//
//   addToJobProcessOrQueue({websocketNumber: 3, skipToFront: false});
//   addToJobProcessOrQueue({websocketNumber: 4, skipToFront: true});
//
//   l(global.newQueue);
// }

// main();

// async function delay(delayInSeconds) {
//   await new Promise(resolve => setTimeout(resolve, delayInSeconds * 1000));
// }
//
// function generateRandomNumber(){
//   return Math.floor(Math.random() * 4 + 3);
// }

// async function main(){
//   addToJobProcessOrQueue({ websocketNumber: '1234', seconds: 15 });
//   await delay(generateRandomNumber());
//   // l('delay done')
//   addToJobProcessOrQueue({ websocketNumber: '2345', seconds: 8 });
//   await delay(generateRandomNumber());
//   // l('delay done')
//   addToJobProcessOrQueue({ websocketNumber: '5678', seconds: 5 });
// }

// main();

// setInterval(() => {
//   l('job object');
//   l(jobProcesses);
//   l('queue');
//   l(newQueue);
// }, 1000);

// async function delayJob(seconds){
//   l('delaying 5000');
//   await delay(seconds * 1000);
//   l('delay done');
// }
//
// const newDelayJob = delayJob(3);
// l(newDelayJob)
//
// async function main1(){
//   l('starting');
//   await delay(5000);
//   l('delay 1 done');
//   await newDelayJob;
// }
//
// main1()

// function addJobToProcessesObject(processNumber, jobObject){
//
// }

// async function addToJobProcessOrQueue({ websocketNumber, seconds }){
//   let startedJob = false;
//   for (let prop in jobProcesses) {
//     const propValue = jobProcesses[prop];
//     // l(prop, jobObject[prop]);
//
//     if(propValue === undefined){
//       jobProcesses[prop] = websocketNumber;
//       runJob({ seconds, websocketNumber });
//       startedJob = true;
//       return
//     }
//     l(prop, jobProcesses[prop]);
//   }
//
//   if(!startedJob){
//     queue.push({
//       websocketNumber,
//       seconds,
//     })
//     l('added to queue');
//   }
// }


// async function doNextQueueItem(){
//   if(queue.length > 0){
//     const nextItem = queue.shift();
//     await nextItem();
//     doNextQueueItem();
//   }
// }

================
File: queue/queue.js
================
global.queueJobs = [];

global.queueItems = [];

function addItemToQueue (queueData) {
  global.queueItems.push(queueData)
}

function addItemToQueueJobs (queueData) {
  global.queueJobs.push(queueData)
}

function updateQueueItemStatus (websocketNumber, status) {
  const item = global.queueItems.find((item) => item.websocketNumber === websocketNumber);
  if (item && item.status !== 'completed') {
    item.status = status;
  }
}

function getNumberOfPendingOrProcessingJobs (ip) {
  const numberOfPendingOrProcessingJobs = global.queueItems.filter((item) => item.ip === ip && (item.status === 'pending' || item.status === 'processing')).length;
  return numberOfPendingOrProcessingJobs;
}

module.exports = {
  addItemToQueue,
  addItemToQueueJobs,
  updateQueueItemStatus,
  getNumberOfPendingOrProcessingJobs
}

================
File: routes/admin.js
================
// see files
const _ = require('lodash');
const express = require('express');
const router = express.Router();
const { getAllDirectories, getMatchingFiles } = require('../lib/files');

router.get('/files', async function (req, res, next) {
  try {
    const { password, language } = req.query;

    const keepMedia = req.query.keepMedia === 'true';

    if (password !== process.env.FILES_PASSWORD) {
      res.redirect('/404')
    } else {
      const dir = './transcriptions';

      //
      let files = await getAllDirectories('./transcriptions');

      // log files length
      l('files length');
      l(files.length);
      // l(files);

      // TODO: what other things to match against?
      files = await getMatchingFiles({ dir, files, language, keepMedia });

      files = _.orderBy(files, (file) => new Date(file.processingData.finishedAT), 'desc');

      // // log files length
      // l('files length');
      // l(files.length);
      //
      // files = await sortByModifiedAtTime('./transcriptions');


      // most recently effected files first (non-destructive, functional)
      // files = [].concat(files).reverse();

      // log files length
      // l('files length');
      // l(files.length);
      //
      // l('returning');
      // l(files);

      return res.render('files', {
        // list of file names
        files,
        title: 'Files',
      })
    }

  } catch (err) {
    l('err');
    l(err);
  }
});

// see files
router.get('/learnserbian', async function (req, res, next) {
  try {

    const dir = './transcriptions';
    //
    let files = await getAllDirectories('./transcriptions');

    const language = 'Serbian';
    const keepMedia = true;

    // TODO: what other things to match against?
    files = await getMatchingFiles({ dir, files, language, keepMedia });

    l('files length');
    l(files.length);
    l(files);

    files = files.filter(function (file) {
      return file.processingData.translatedLanguages.length;
    });

    // TODO: finishedAT is misspelled
    files = _.orderBy(files, (file) => new Date(file.processingData.finishedAT), 'desc');

    return res.render('files', {
      // list of file names
      files,
      title: 'Files',
    })

  } catch (err) {
    l('err');
    l(err);
  }
});

router.get('/admin', async function (req, res, next) {
  try {
    const { password } = req.query;

    if (process.env.NODE_ENV !== 'development' && password !== process.env.FILES_PASSWORD) {
      res.redirect('/404')
    } else {

      // l('jobProcesses')
      // l(jobProcesses)

      const cleanedUpJobProcessObject = {};

      for (const jobProcessNumber in jobProcesses) {
        let value = jobProcesses[jobProcessNumber];
        if (!value) {
          cleanedUpJobProcessObject[jobProcessNumber] = {};
          continue
        }

        let newItem = Object.assign({}, value);
        delete newItem.directorySafeFileNameWithoutExtension;
        delete newItem.directorySafeFileNameWithExtension;
        delete newItem.fileSafeNameWithDateTimestamp
        delete newItem.fileSafeNameWithDateTimestampAndExtension
        cleanedUpJobProcessObject[jobProcessNumber] = newItem;
      }

      // l('cleanedUpJobProcessObject')
      // l(cleanedUpJobProcessObject)

      const cleanedUpNewQueue = [];

      // l('global newqueue')
      // l(global.newQueue);

      // cleanup new queue items
      for (const queueItem of global.newQueue) {

        if (!queueItem) continue

        let newItem = Object.assign({}, queueItem);

        delete newItem.directorySafeFileNameWithoutExtension;
        delete newItem.directorySafeFileNameWithExtension;
        delete newItem.fileSafeNameWithDateTimestamp
        delete newItem.fileSafeNameWithDateTimestampAndExtension
        cleanedUpNewQueue.push(newItem);
      }

      // l('cleanedUpNewQueue')
      // l(cleanedUpNewQueue)

      return res.render('admin', {
        title: 'Admin',
        processes: cleanedUpJobProcessObject,
        newQueue: cleanedUpNewQueue || [],
        transcriptions: global.transcriptions,
        webSocketData: global.webSocketData,
      })
    }

  } catch (err) {
    l('err');
    l(err);
  }
});

module.exports = router;

================
File: routes/api.js
================
const path = require('path');
const express = require('express');
const axios = require('axios');
const fs = require('fs-extra');
const FormData = require('form-data');
const multer = require('multer');
const router = express.Router();
const transcribe = require('../transcribe/transcribe-api-wrapped')
const constants = require('../constants/constants');
const filenamify = require('filenamify');
const createTranslatedFiles = require('../translate/translate-files-api');
const { downloadFileApi, getFilename} = require('../downloading/yt-dlp-download');
const { languagesToTranslateTo, newLanguagesMap, translationLanguages } = constants;
const { modelsArray, whisperLanguagesHumanReadableArray } = constants;
const { writeToProcessingDataFile, createFileNames, makeFileNameSafe } = require('../lib/transcribing');

const l = console.log;

// generate random 10 digit number
function generateRandomNumber () {
  return Math.floor(Math.random() * 10000000000).toString();
}

const storage = multer.diskStorage({ // notice  you are calling the multer.diskStorage() method here, not multer()
  destination: function (req, file, cb) {
    cb(null, './uploads/')
  },
});

let upload = multer({ storage });

router.post('/api', upload.single('file'), async function (req, res, next) {
  try {
    // fix body data
    const postBodyData = Object.assign({},req.body)

    // get file names
    const file = req.file;
    let originalFileName, uploadFileName, uploadFilePath;
    if (file) {
      originalFileName = file.originalname;
      uploadFileName = file.filename;
      uploadFilePath = file.path;
    }

    l('originalFileName');
    l(originalFileName);

    l('uploadFileName');
    l(uploadFileName)

    l(req.file);

    // get language and model
    const { model, language, downloadLink, apiToken, websocketNumber } = postBodyData;

    let numberToUse;
    if (downloadLink) {
      numberToUse = generateRandomNumber();
    } else {
      numberToUse = websocketNumber;
    }

    l('postBodyData');
    l(postBodyData);

    // get model values as array
    const validModelValues = modelsArray.map((model) => model.value);

    const authTokenString = await fs.readFile(`${process.cwd()}/constants/apiTokens.txt`, 'utf8');
    const authTokenStringsAsArray = authTokenString.split(',');
    const authedByToken = authTokenStringsAsArray.includes(apiToken);

    if (process.env.NODE_ENV === 'production' && !authedByToken) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    // nothing to transcribe
    if (!downloadLink && !file) {
      // eslint-disable-next-line quotes
      return res.status(400).json({error: `Please pass either a 'file' or 'downloadLink'`});
    }

    // bad model name
    if (!validModelValues.includes(model)) {
      return res.status(400).send({error: `Your model of '${model}' is not valid. Please choose one of the following: ${validModelValues.join(', ')}`});
    }

    // bad language name
    if (!whisperLanguagesHumanReadableArray.includes(language)) {
      return res.status(400).send({error: `Your language of '${language}' is not valid. Please choose one of the following: ${whisperLanguagesHumanReadableArray.join(', ')}`});
    }

    // TODO: implement this
    let originalFileNameWithExtension, originalFileExtension, originalFileNameWithoutExtension, directorySafeFileNameWithoutExtension;
    if (file) {
      ({
        originalFileNameWithExtension,
        originalFileExtension,
        originalFileNameWithoutExtension,
        directorySafeFileNameWithoutExtension
      } = createFileNames(originalFileName));
    }

    let filename;
    if (downloadLink) {
      // hit yt-dlp and get file title name
      filename =  await getFilename(downloadLink);
    } else {
      filename = originalFileNameWithExtension
    }

    const directoryName = makeFileNameSafe(filename)

    l('directoryName');
    l(directoryName);

    l('filename');
    l(filename);

    // build this properly
    const host = process.env.NODE_ENV === 'production' ? 'https://freesubtitles.ai' : 'http://localhost:3001';

    // create directory for transcriptions
    await fs.mkdirp(`${process.cwd()}/transcriptions/${numberToUse}`);

    const newPath = `${process.cwd()}/transcriptions/${numberToUse}/${numberToUse}`;

    // setup path for processing data
    const processingDataPath = `${process.cwd()}/transcriptions/${numberToUse}/processing_data.json`;

    // save initial data
    await writeToProcessingDataFile(processingDataPath, {
      model,
      language,
      downloadLink,
      filename,
      apiToken
    })

    let matchingFile;
    if (downloadLink) {

      res.send({
        message: 'starting-download',
        // where the data will be sent from
        transcribeDataEndpoint: `${host}/api/${numberToUse}`,
        fileTitle: filename,
      });

      await writeToProcessingDataFile(processingDataPath, {
        status: 'downloading',
      })

      // download file with name as the random number
      await downloadFileApi({
        videoUrl: downloadLink,
        numberToUse,
      });

      // check uploads directory
      const files = await fs.promises.readdir(`${process.cwd()}/uploads`);

      // get matching file (I don't think we always know the extension)
      matchingFile = files.filter((file) => file.startsWith(numberToUse))[0];
      l(matchingFile);

      uploadFilePath = `${process.cwd()}/uploads/${matchingFile}`;
    } else {
      res.send({
        message: 'starting-transcription',
        // where the data will be sent from
        transcribeDataEndpoint: `${host}/api/${numberToUse}`,
        fileTitle: filename,
      });
    }

    // move transcribed file to the correct location (TODO: do this before transcribing)
    await fs.move(uploadFilePath, newPath)

    await writeToProcessingDataFile(processingDataPath, {
      status: 'starting-transcription',
    })

    // todo: rename to transcribeAndTranslate
    await transcribe({
      language,
      model,
      originalFileExtension,
      uploadFileName: matchingFile || originalFileName, //
      uploadFilePath: newPath,
      originalFileName,
      numberToUse,
    })

  } catch (err) {
    l('err')
    l(err);
    return res.status(500).send({error: `Something went wrong: ${err}`});
  }
});

// get info about the transcription via api
router.get('/api/:sdHash', async function (req, res, next) {
  try {

    l('Getting info by SDHash');

    // TODO: should rename this
    const sdHash = req.params.sdHash;

    l('sd hash')
    l(sdHash);

    // get processing data path
    const processingData = JSON.parse(await fs.readFile(`./transcriptions/${sdHash}/processing_data.json`, 'utf8'));

    // get data from processing data
    const {
      language,
      languageCode,
      translatedLanguages,
      status: transcriptionStatus,
      progress
    } = processingData;

    // transcription processing or translating
    if (transcriptionStatus === 'processing' || transcriptionStatus === 'translating') {
      // send current processing data
      return res.send({
        status: transcriptionStatus,
        sdHash,
        progress,
        processingData
      })

    /** transcription successfully completed, attach VTT files **/
    } else if (transcriptionStatus === 'completed') {
      let subtitles = [];

      // add original vtt
      const originalVtt = await fs.readFile(`./transcriptions/${sdHash}/${sdHash}.vtt`, 'utf8');
      subtitles.push({
        language,
        languageCode,
        webVtt: originalVtt
      })

      // for (const translatedLanguage of translatedLanguages) {
      //   const originalVtt = await fs.readFile(`./transcriptions/${sdHash}/${sdHash}_${translatedLanguage}.vtt`, 'utf8');
      //   subtitles.push({
      //     language: translatedLanguage,
      //     languageCode: getCodeFromLanguageName(translatedLanguage),
      //     webVtt: originalVtt
      //   })
      // }

      // send response as json
      const responseObject = {
        status: 'completed',
        sdHash,
        processingData,
        subtitles
      }
      // l('responseObject');
      // l(responseObject);

      return res.send(responseObject)
    }



    return res.send(processingData);

    // res.send('ok');
  } catch (err) {
    l('err');
    l(err);
  }
})





/** UNFINISHED FUNCTIONALITY **/
// post file from backend
router.post('/post', async function (req, res, next) {
  try {
    l(req.body);
    l(req.params);

    const endpointToHit = 'http:localhost:3000'

    // Create a new form instance
    const form = new FormData();

    const file = await fs.readFile('./ljubav.srt');
    l('file');
    l(file);

    form.append('subtitles', file, 'subtitles');

    form.append('filename', 'ljubav.srt');


    l('form headers');
    l(form.getHeaders())

    const response = await axios.post(endpointToHit, form, {
      headers: {
        ...form.getHeaders(),
      },
      data: {
        foo: 'bar', // This is the body part
      }
    });

    // l('response');
    // l(response);

    // res.send('ok');
  } catch (err) {
    l('err');
    l(err);
  }
})

module.exports = router;

================
File: routes/index.js
================
const express = require('express');
const router = express.Router();
const {forHumans, decrementBySecond} = require('../helpers/helpers')
const { modelsArray, languagesArray } = require('../constants/constants');
const fs = require('fs-extra')

const l = console.log;

const uploadPath =  process.env.UPLOAD_PATH || 'localhost:3000';

const nodeEnv = process.env.NODE_ENV || 'development';
l({nodeEnv});

const uploadLimitInMB = nodeEnv === 'production' ? process.env.UPLOAD_FILE_SIZE_LIMIT_IN_MB : 3000;
l({uploadLimitInMB});

// home page
router.get('/', function (req, res, next) {
  const isFreeSubtitles = req.hostname === 'freesubtitles.ai';

  // transcribe frontend page
  res.render('index/index', {
    title: 'Transcribe File',
    uploadPath,
    forHumans,
    nodeEnv,
    siteStats: global.siteStats,
    isFreeSubtitles,
    uploadLimitInMB,
    modelsArray,
    languagesArray,
    decrementBySecond
  });
});

// home page
router.get('/ytdlp', async function (req, res, next) {

  const { password, user, skip } = req.query;

  const usersString = await fs.readFile(`${process.cwd()}/constants/ytdlpUsers.txt`, 'utf8');
  const users = usersString.split(',');
  const userAuthed = users.includes(user);

  const passwordAuthed = password === process.env.FILES_PASSWORD

  const authedByPasswordOrUser = userAuthed || passwordAuthed;

  if (nodeEnv === 'production' && !authedByPasswordOrUser) {
    return res.redirect('/404')
  }

  const domainName = req.hostname;

  const isFreeSubtitles = domainName === 'freesubtitles.ai';

  // transcribe frontend page
  res.render('index/index', {
    title: 'Transcribe File',
    uploadPath,
    forHumans,
    nodeEnv,
    siteStats: global.siteStats,
    isFreeSubtitles,
    uploadLimitInMB,
    modelsArray,
    languagesArray,
    decrementBySecond,
    ytdlp: true,
    user,
    skipToFront: skip
  });
});

router.get('/queue', function (req, res, next) {

  const { password } = req.query;

  if (nodeEnv === 'production' && password !== process.env.FILES_PASSWORD) {
    return res.redirect('/404')
  }

  const queueData = global.queueItems;

  const reversedQueueData = queueData.slice().reverse();

  res.render('queue', {
    title: 'Queue',
    queueData: reversedQueueData,
  })
});

// router.get("/transcriptions/:path/:filename" , async function(req, res, next) {
//   console.log(req.params);
//   res.sendFile(`${process.cwd()}/transcriptions/${req.params.path}/${req.params.filename}`);
// });

module.exports = router;

================
File: routes/player.js
================
const { stripOutTextAndTimestamps, reformatVtt } = require ('../translate/helpers')
const { Readable } = require('stream');
const fs = require('fs-extra');
const {newLanguagesMap, languagesToTranscribe} = require('../constants/constants');
const express = require('express');
let router = express.Router();


/** PLYR PLAYER **/
router.get('/player/:filename' , async function (req, res, next) {
  try {
    const { password } = req.query;

    const userAuthed = password === process.env.FILES_PASSWORD

    const fileNameWithoutExtension = req.params.filename

    const processDirectory = process.cwd();

    const containingFolder = `${processDirectory}/transcriptions/${fileNameWithoutExtension}`

    const processingDataPath = `${containingFolder}/processing_data.json`;

    const processingData = JSON.parse(await fs.readFile(processingDataPath, 'utf8'));


    const filePathWithoutExtension = `/transcriptions/${fileNameWithoutExtension}/${processingData.directoryFileName}`;

    // l('filePathWithoutExtension')
    // l(filePathWithoutExtension);

    const translatedLanguages = processingData.translatedLanguages;

    // TODO: check that it doesn't include the original language? or it never will?
    const languagesToLoop = newLanguagesMap.filter(function (language) {
      return translatedLanguages.includes(language.name)
    });

    delete processingData.strippedText;
    delete processingData.timestampsArray;

    // l('processing data');
    // l(processingData);
    //
    // l('languages to loop');
    // l(languagesToLoop);

    let allLanguages = languagesToLoop.slice();

    allLanguages.push({
      name: processingData.language,
      languageCode: processingData.languageCode
    })

    // l('all languages');
    // l(allLanguages);

    res.render('player/player', {
      filePath: filePathWithoutExtension,
      languages: languagesToTranscribe,
      fileNameWithoutExtension,
      filePathWithoutExtension,
      processingData,
      title: processingData.filename,
      languagesToLoop,
      allLanguages,
      renderedFilename: req.params.filename,
      userAuthed,
      password
      // vttPath,
      // fileSource
    })
  } catch (err) {
    l('err');
    l(err);
    res.redirect('/404')
  }
});

/** player route to add translation  **/
router.get('/player/:filename/add' , async function (req, res, next) {
  try {

    const fileNameWithoutExtension = req.params.filename

    const processDirectory = process.cwd();

    const containingFolder = `${processDirectory}/transcriptions/${fileNameWithoutExtension}`

    const processingDataPath = `${containingFolder}/processing_data.json`;

    const processingData = JSON.parse(await fs.readFile(processingDataPath, 'utf8'));

    const originalVtt = await fs.readFile(`${containingFolder}/${processingData.directoryFileName}.vtt`, 'utf8');

    res.render('addTranslation/addTranslation', {
      title: 'Add Translation',
      renderedFilename: fileNameWithoutExtension,
      originalVtt
      // vttPath,
      // fileSource
    })
  } catch (err) {
    l('err');
    l(err);
    res.send(err);
  }
});

/** PLYR PLAYER **/
router.post('/player/:filename/add' , async function (req, res, next) {
  try {

    const { language } = req.body;

    const fileNameWithoutExtension = req.params.filename

    const newVtt = req.body.message;

    const processDirectory = process.cwd();

    const containingFolder = `${processDirectory}/transcriptions/${fileNameWithoutExtension}`

    const processingDataPath = `${containingFolder}/processing_data.json`;

    const processingData = JSON.parse(await fs.readFile(processingDataPath, 'utf8'));

    const originalVttPath = `${containingFolder}/${processingData.directoryFileName}.vtt`;

    const originalVtt = await fs.readFile(`${containingFolder}/${processingData.directoryFileName}.vtt`, 'utf8');

    const inputStream = new Readable(newVtt);

    inputStream.push(newVtt);

    inputStream.push(null);

    l(inputStream)

    const { strippedText } = await stripOutTextAndTimestamps(inputStream, true);

    l('stripped text');
    l(strippedText);

    const { timestampsArray } = await stripOutTextAndTimestamps(originalVttPath);

    l('timestamps array');
    l(timestampsArray);

    const reformatted = reformatVtt(timestampsArray, strippedText);

    l(reformatted);
    l('refomatted');

    const newVttPath = `${containingFolder}/${processingData.directoryFileName}_${language}.vtt`;

    const originalFileVtt = `${containingFolder}/${processingData.directoryFileName}_${processingData.language}.vtt`;

    await fs.writeFile(newVttPath, reformatted, 'utf-8');

    processingData.translatedLanguages.push(language);

    processingData.keepMedia = true;

    await fs.writeFile(processingDataPath, JSON.stringify(processingData), 'utf-8');

    await fs.writeFile(originalFileVtt, originalVtt, 'utf-8');

    return res.redirect(`/player/${req.params.filename}`)

  } catch (err) {
    l('err');
    l(err);
    res.send(err);
  }
});

/** CHANGE KEEP MEDIA **/
router.post('/player/:filename/keepMedia' , async function (req, res, next) {
  try {
    const { password } = req.query;

    const keepMedia = req.query.keepMedia;

    const shouldKeepMedia = keepMedia === 'true';

    l('keep media');
    l(keepMedia);

    l('password');
    l(password);

    const fileNameWithoutExtension = req.params.filename

    const processDirectory = process.cwd();

    const containingFolder = `${processDirectory}/transcriptions/${fileNameWithoutExtension}`

    const processingDataPath = `${containingFolder}/processing_data.json`;

    const processingData = JSON.parse(await fs.readFile(processingDataPath, 'utf8'));

    if (shouldKeepMedia) {
      processingData.keepMedia = true;
    } else {
      processingData.keepMedia = false;
    }

    await fs.writeFile(processingDataPath, JSON.stringify(processingData), 'utf-8');

    return res.redirect(`/player/${req.params.filename}`)

  } catch (err) {
    l('err');
    l(err);
    res.send(err);
  }
});


module.exports = router;

================
File: routes/stats.js
================
const express = require('express');
const router = express.Router();
const moment = require('moment');
const { forHumansHoursAndMinutes } = require('../helpers/helpers')

const { getAllDirectories } = require('../lib/files');

// see files
router.get('/stats', async function (req, res, next) {
  try {

    const stats = {
      lastHour: 0,
      last24h: 0,
      lastWeek: 0,
      lastMonth: 0,
      allTime: 0
    }

    const transcriptionTime = {
      lastHour: 0,
      last24h: 0,
      lastWeek: 0,
      lastMonth: 0,
      allTime: 0
    }

    //
    let files = await getAllDirectories('./transcriptions');

    const withinLastHour = moment().subtract(1, 'hours').valueOf();
    const within24h = moment().subtract(1, 'days').valueOf();
    const withinWeek = moment().subtract(1, 'weeks').valueOf();
    const withinMonth = moment().subtract(1, 'months').valueOf();

    let languages = {};

    for (const file of files) {
      if (file.timestamp > withinLastHour) {
        stats.lastHour++;
        transcriptionTime.lastHour += file.processingData.uploadDurationInSeconds;
      }
      if (file.timestamp > within24h) {
        stats.last24h++;
        transcriptionTime.last24h += file.processingData.uploadDurationInSeconds;
      }
      if (file.timestamp > withinWeek) {
        stats.lastWeek++;
        transcriptionTime.lastWeek += file.processingData.uploadDurationInSeconds;
      }
      if (file.timestamp > withinMonth) {
        stats.lastMonth++;
        transcriptionTime.lastMonth += file.processingData.uploadDurationInSeconds;
      }
      stats.allTime++;
      transcriptionTime.allTime += file.processingData.uploadDurationInSeconds;

      if (file.processingData.language) {
        if (!languages[file.processingData.language]) {
          languages[file.processingData.language] = 1;
        } else {
          languages[file.processingData.language]++;
        }
      }
    }

    // l('files');
    // l(files);

    transcriptionTime.lastHour = forHumansHoursAndMinutes(transcriptionTime.lastHour);
    transcriptionTime.last24h = forHumansHoursAndMinutes(transcriptionTime.last24h);
    transcriptionTime.lastWeek = forHumansHoursAndMinutes(transcriptionTime.lastWeek);
    transcriptionTime.lastMonth = forHumansHoursAndMinutes(transcriptionTime.lastMonth);
    transcriptionTime.allTime = forHumansHoursAndMinutes(transcriptionTime.allTime);

    // l('languages');
    // l(languages);

    // sort languages by count
    const entries = Object.entries(languages);

    // Sort the array using the value
    entries.sort((a, b) => b[1] - a[1]);

    // Reconstruct the object
    const sortedObj = Object.fromEntries(entries);

    // l('sortedObj');
    // l(sortedObj);

    // l('languages');
    // l(languages);

    return res.render('stats/stats', {
      // list of file names
      title: 'Stats',
      stats,
      transcriptionTime,
      languages: sortedObj
    });
  } catch (err) {
    l('err');
    l(err);
  }
});

module.exports = router;

================
File: routes/transcribe.js
================
const url = require('url');
const path = require('path');
const ffprobe = require('ffprobe');
const moment = require('moment/moment');
const Queue = require('promise-queue');
const multer = require('multer');
const express = require('express');
const router = express.Router();
const which = require('which');
const ffprobePath = which.sync('ffprobe')
const fs = require('fs-extra');

const { downloadFile, getFilename } = require('../downloading/yt-dlp-download');
const transcribeWrapped = require('../transcribe/transcribe-wrapped');
const { languagesToTranslateTo } = require('../constants/constants');
const {forHumansNoSeconds} = require('../helpers/helpers');
const {makeFileNameSafe} = require('../lib/files');
const { addItemToQueue, getNumberOfPendingOrProcessingJobs } = require('../queue/queue');
const { addToJobProcessOrQueue, amountOfRunningJobs } = require('../queue/newQueue');


const nodeEnv = process.env.NODE_ENV || 'development';
const maxConcurrentJobs = Number(process.env.CONCURRENT_AMOUNT);
const uploadLimitInMB = nodeEnv === 'production' ? Number(process.env.UPLOAD_FILE_SIZE_LIMIT_IN_MB) : 3000;

l(`CONCURRENT JOBS ALLOWED AMOUNT: ${maxConcurrentJobs}`);

const storage = multer.diskStorage({ // notice you are calling the multer.diskStorage() method here, not multer()
  destination: function (req, file, cb) {
    cb(null, './uploads/')
  },
});

let upload = multer({ storage });

router.post('/file', upload.single('file'), async function (req, res, next) {
  // l(global.ws);
  let websocketConnection;

  try {
    l(req.file);
    l(req.body);

    const referer = req.headers.referer;
    const urlObject = url.parse(referer);
    const pathname = urlObject.pathname;
    const isYtdlp = pathname === '/ytdlp';

    l('isYtdlp');
    l(isYtdlp);

    let language = req.body.language;
    let model = req.body.model;
    const websocketNumber = req.body.websocketNumber;
    const shouldTranslate = req.body.shouldTranslate === 'true';
    const downloadLink = req.body.downloadLink;
    const { user, skipToFront, uploadTimeStarted } = req.body

    const passedFile = req.file;
    let downloadedFile = false;

    const uploadTimeFinished = new Date();

    // this shouldn't happen but there's some sort of frontend bug
    if (!language || language === 'undefined' || language === 'Auto-Detect') {
      language = 'auto-detect';
    }

    // make the model medium by default
    if (!model) {
      model = 'medium';
    }

    if (model === 'tiny.en' || model === 'base.en' || model === 'small.en' || model === 'medium.en') {
      language = 'English'
    }

    let filename;

    l(downloadLink);

    function matchByWebsocketNumber (item) {
      return item.websocketNumber === websocketNumber;
    }

    // websocket number is pushed when it connects on page load
    // l(global.webSocketData);
    const websocket = global.webSocketData.find(matchByWebsocketNumber)
    if (websocket) {
      websocketConnection = websocket.websocket;
    } else {
      throw new Error('no websocket!');
    }

    let originalFileNameWithExtension, uploadedFilePath, uploadGeneratedFilename;
    if (passedFile) {

      originalFileNameWithExtension = Buffer.from(req.file.originalname, 'latin1').toString('utf8');
      uploadedFilePath = req.file.path;
      uploadGeneratedFilename = req.file.filename;
      l('uploadedFilePath');
      l(uploadedFilePath);
    } else if (downloadLink) {

      websocketConnection.send(JSON.stringify({
        message: 'downloadInfo',
        fileName: downloadLink,
        percentDownloaded: 0,
      }), function () {});

      // TODO: not the world's greatest implemention
      function generateRandomNumber () {
        return Math.floor(Math.random() * 10000000000).toString();
      }

      const randomNumber = generateRandomNumber();

      filename =  await getFilename(downloadLink);
      // remove linebreaks, this was causing bugs
      filename = filename.replace(/\r?\n|\r/g, '');
      l('filename');
      l(filename);
      uploadGeneratedFilename = filename;
      originalFileNameWithExtension = filename;
      const baseName = path.parse(filename).name;
      const extension = path.parse(filename).ext;
      uploadedFilePath = `uploads/${randomNumber}${extension}`;

      res.send('download');

      // TODO: pass websocket connection and output download progress to frontend
      await downloadFile({
        videoUrl: downloadLink,
        filepath: uploadedFilePath,
        randomNumber,
        websocketConnection,
        filename,
        websocketNumber,
      });
      downloadedFile = true;

      uploadGeneratedFilename = baseName;

    } else {
      throw new Error('No file or download link provided');
      // ERROR
    }

    l('uploadedFilePath');
    l(uploadedFilePath);

    // get upload duration
    const ffprobeResponse = await ffprobe(uploadedFilePath, { path: ffprobePath });

    const audioStream = ffprobeResponse.streams.filter(stream => stream.codec_type === 'audio')[0];
    const uploadDurationInSeconds = Math.round(audioStream.duration);

    const stats = await fs.promises.stat(uploadedFilePath);
    const fileSizeInBytes = stats.size;
    const fileSizeInMB = Number(fileSizeInBytes / 1048576).toFixed(1);

    // TODO: pull out into a function
    // error if on FS and over file size limit or duration limit
    const domainName = req.hostname;

    const isFreeSubtitles = domainName === 'freesubtitles.ai';
    if (isFreeSubtitles && !isYtdlp) {

      const amountOfSecondsInHour = 60 * 60;
      if (uploadDurationInSeconds > amountOfSecondsInHour) {
        const uploadLengthErrorMessage = `Your upload length is ${forHumansNoSeconds(uploadDurationInSeconds)}, but currently the maximum length allowed is only 1 hour`;
        return res.status(400).send(uploadLengthErrorMessage);
      }
      if (fileSizeInMB > uploadLimitInMB) {
        const uploadSizeErrorMessage = `Your upload size is ${fileSizeInMB} MB, but the maximum size currently allowed is ${uploadLimitInMB} MB.`;
        return res.status(400).send(uploadSizeErrorMessage);
      }
    }

    // TODO: pull into its own function
    /** WEBSOCKET FUNCTIONALITY **/
    // load websocket by passed number


    const currentlyRunningJobs = amountOfRunningJobs();
    const amountInQueue = global.newQueue.length
    const totalOutstanding = currentlyRunningJobs + amountInQueue - maxConcurrentJobs + 1;

    l('totaloutstanding');
    l(totalOutstanding);

    /** WEBSOCKET FUNCTIONALITY END **/

    const originalFileExtension = path.parse(originalFileNameWithExtension).ext;
    const originalFileNameWithoutExtension = path.parse(originalFileNameWithExtension).name;

    // directory name
    const directorySafeFileNameWithoutExtension = makeFileNameSafe(originalFileNameWithoutExtension)

    // used for the final media resting place
    const directorySafeFileNameWithExtension = `${directorySafeFileNameWithoutExtension}${originalFileExtension}`

    const timestampString = moment(new Date()).format('DD-MMMM-YYYY_HH_mm_ss');

    const separator = '--'

    const fileSafeNameWithDateTimestamp = `${directorySafeFileNameWithoutExtension}${separator}${timestampString}`;

    const fileSafeNameWithDateTimestampAndExtension = `${directorySafeFileNameWithoutExtension}${separator}${timestampString}${originalFileExtension}`;

    // pass ip to queue
    const ip = req.headers['x-forwarded-for'] ||
      req.socket.remoteAddress ||
      null;

    // allow admin to see items in the queue
    addItemToQueue({
      model,
      language,
      filename: originalFileNameWithExtension,
      ip,
      uploadDurationInSeconds,
      shouldTranslate,
      fileSizeInMB,
      startedAt: new Date(),
      status: 'pending',
      websocketNumber,
      ...(user && { user }),
      ...(downloadLink && { downloadLink }),
      ...(skipToFront && { skipToFront }),
      totalOutstanding,
    })

    const transcriptionJobItem = {
      uploadedFilePath,
      language,
      model,
      directorySafeFileNameWithoutExtension,
      directorySafeFileNameWithExtension,
      originalFileNameWithExtension,
      fileSafeNameWithDateTimestamp,
      fileSafeNameWithDateTimestampAndExtension,
      uploadGeneratedFilename,
      shouldTranslate,
      uploadDurationInSeconds,
      fileSizeInMB,
      ...(user && { user }),
      ...(downloadLink && { downloadLink }),
      skipToFront: skipToFront === 'true',
      totalOutstanding,
      ip,

      // websocket/queue
      websocketConnection,
      websocketNumber,
      languagesToTranslateTo,
    }

    // l('transcriptionJobItem');
    // l(transcriptionJobItem);
    addToJobProcessOrQueue(transcriptionJobItem);

    const obj = JSON.parse(JSON.stringify(req.body));
    l(obj);

    // l(req.files);

    // assuming already sent from above
    if (!downloadedFile) {
      res.send('ok');
    }
    // req.files is array of uploaded files
    // req.body will contain the text fields, if there were any
  } catch (err) {
    l('err from transcribe route')
    l(err);

    // websocketConnection.terminate()
    // throw (err);
  }
});

router.get('/checkingOutstandingProcesses', async function (req, res, next) {
  const ip = req.headers['x-forwarded-for'] || req.socket.remoteAddress || null;

  const outstandingJobsAmount = getNumberOfPendingOrProcessingJobs(ip);

  l('outstandingJobsAmount');
  l(outstandingJobsAmount);

  if (outstandingJobsAmount >= 3) {
    res.send('tooMany');
  } else {
    res.send('ok');
  }

  try {

  } catch (err) {
    l('err from transcribe route')
    l(err);

    // websocketConnection.terminate()
    // throw (err);
  }
});

module.exports = router;

================
File: routes/users.js
================
const express = require('express');
const router = express.Router();

/* GET users listing. */
router.get('/', function (req, res, next) {
  res.send('respond with a resource');
});

module.exports = router;

================
File: scripts/deleteTranscriptionUploads.js
================
const {tr} = require('language-name-map/map');
let l = console.log;
const fs = require('fs-extra');
const path = require('path');

const mediaFileExtensions = [
  // Audio file extensions
  '.aac',
  '.ac3',
  '.adts',
  '.aif',
  '.aiff',
  '.aifc',
  '.amr',
  '.au',
  '.awb',
  '.dct',
  '.dss',
  '.dvf',
  '.flac',
  '.gsm',
  '.m4a',
  '.m4p',
  '.mmf',
  '.mp3',
  '.mpc',
  '.msv',
  '.oga',
  '.ogg',
  '.opus',
  '.ra',
  '.ram',
  '.raw',
  '.sln',
  '.tta',
  '.vox',
  '.wav',
  '.wma',

  // Video file extensions
  '.3g2',
  '.3gp',
  '.3gpp',
  '.asf',
  '.avi',
  '.dat',
  '.flv',
  '.m2ts',
  '.m4v',
  '.mkv',
  '.mod',
  '.mov',
  '.mp4',
  '.mpe',
  '.mpeg',
  '.mpg',
  '.mts',
  '.ogv',
  '.qt',
  '.rm',
  '.rmvb',
  '.swf',
  '.ts',
  '.vob',
  '.webm',
  '.wmv'
];


// get argument from command line
const shouldDeleteFiles = process.argv[2] === 'delete';
const logDeleteOnly = process.argv[2] === 'toDelete';
const logKeepOnly = process.argv[2] === 'toKeep';

function logInBlueColor (message) {
  console.log(`\x1b[34m${message}\x1b[0m`);
}

function logInRedColor (message) {
  console.log(`\x1b[31m${message}\x1b[0m`);
}

if (logDeleteOnly) {
  logInRedColor = function () {}; // disable logging
}
if (logKeepOnly) {
  logInBlueColor = function () {}; // disable logging
}

async function deleteAllMediaFiles ({ dirPath }) {
  // Get an array of all the files in the directory
  const files = await fs.promises.readdir(dirPath);

  // Loop through all the files in the directory
  for (const file of files) {
    // get file extension using path module
    const fileExtension = path.extname(file);

    if (mediaFileExtensions.includes(fileExtension)) {
      try {
        await fs.promises.unlink(`${dirPath}/${file}`);
      } catch (error) {
        l('error');
        l(error);
        console.error(`Error deleting file: ${dirPath}/${file}`);
      }

    }
  }
}

async function findMediaFileInDirectory (directory) {
  const files = await fs.promises.readdir(directory);
  for (const file of files) {
    // get file extension using path module
    const fileExtension = path.extname(file);
    if (mediaFileExtensions.includes(fileExtension)) {
      return file;
    }
  }
  return false
}


// delete files that are over 24h old script
const deleteOldFiles = async function (shouldDelete = false) {
  try {

    let deletingFiles = shouldDelete || shouldDeleteFiles;

    const processDirectory = process.cwd();
    const transcriptionsDirectory = `${processDirectory}/transcriptions`;
    const transcriptionsDirectoryContents = await fs.readdir(transcriptionsDirectory);

    let totalFileSizeToDelete = 0;

    // loop through all transcription directories
    for (const transcriptionDirectory of transcriptionsDirectoryContents) {
      // check if directory is directory
      const directoryPath = `${transcriptionsDirectory}/${transcriptionDirectory}`;

      // this is guaranteed to exist
      const directoryStats = await fs.stat(directoryPath);

      const isDirectory = directoryStats.isDirectory();

      // only loop through if it's a directory
      if (isDirectory) {
        // check if directory is empty
        const directoryContents = await fs.readdir(directoryPath);

        // get the name of the media file if it exists
        const mediaFile = await findMediaFileInDirectory(directoryPath);

        // get the path to the media
        const mediaFilePath = `${directoryPath}/${mediaFile}`;

        // no media to delete, keep going
        if (!mediaFile) {
          continue;
        }

        // check if directory has a processing_data.json file
        const processingDataPath = `${directoryPath}/processing_data.json`;

        // read processing_data.json file
        // dont error if processingData doesn't exist
        const processingDataExists = await fs.pathExists(processingDataPath);

        // TODO: only implement when it's ready
        if (!processingDataExists) {
          l('deleting media files')
          // await fs.unlink(mediaFilePath);
          continue
        }

        let processingData, fileExistsButJsonError;
        try {
          processingData = JSON.parse(await fs.readFile(processingDataPath, 'utf8'));
        } catch (err) {

          // syntax error
          fileExistsButJsonError = err.toString().includes('SyntaxError');

          // delete the media if json error
          if (fileExistsButJsonError) {
            l('deleting media files')
            // delete the media files
            if (deletingFiles) {
              await deleteAllMediaFiles({ dirPath: directoryPath });
            }
            continue
          }
        }

        // TODO: could have side effects until data saving lands
        if (!processingData) {
          l('no processing data');
          l('deleting media files')
          // await deleteAllMediaFiles({ dirPath: directoryPath });
          continue
        }

        // check if processing data keep media property is true
        const shouldKeepMedia = processingData.keepMedia;

        // if keep media is true, keep going
        if (shouldKeepMedia) {
          l('should keep');
          continue;
        }

        // check if processing_data.json file has a completedAt property
        if (processingData.startedAt) {
          // check if completedAt is over 24h old
          const startedAt = new Date(processingData.startedAt);
          const now = new Date();
          const difference = now - startedAt;
          const hoursDifference = difference / 1000 / 60 / 60;

          const over24Hours = hoursDifference > 24;

          if (over24Hours) {
            l('deleting media files')
            if (deletingFiles && !shouldKeepMedia) {
              // delete mediaFilePath
              await fs.unlink(mediaFilePath);
            }
          } else {
            l('not over 24 hours');
          }

        // there is an issue because the current processing_data.json file doesn't have a startedAt property
        } else {
          l('deleting media files')
          if (deletingFiles) await deleteAllMediaFiles({ dirPath: directoryPath });
        }
      }

      // l('transcriptionsDirectoryContents');
      // l(transcriptionsDirectoryContents);
    }

    logInBlueColor('totalFileSizeToDelete');
    logInBlueColor(totalFileSizeToDelete);
  } catch (err) {
    l('err');
    l(err);
    l(err.stack);
  }
}

// deleteOldFiles();

module.exports = {
  deleteOldFiles
}

================
File: scripts/extractAudioFfmpeg.js
================
const spawn = require('child_process').spawn;
const which = require('which');
const ffprobe = require('ffprobe');

const l = console.log;

const ffmpegPath = which.sync('ffmpeg')

const inputVideoPath = './trimmed.mp4';

// ffmpeg -i input-video.avi -vn -acodec copy output-audio.aac


const ffprobePath = which.sync('ffprobe')

l(process.cwd())

// return

function extractAudio (inputVideoPath, outputAudioPath) {
  return new Promise((resolve, reject) => {
    const ffmpegArguments = [
      '-i', inputVideoPath, // input video path
      '-y', // overwrite output file if it exists
      '-vn', // no video
      '-acodec', 'copy', // copy audio codec (don't re-encode)
      `./${outputAudioPath}`
    ]

    const ffmpegProcess = spawn(ffmpegPath, ffmpegArguments);

    // TODO: implement foundLanguagae here
    // let foundLanguage;
    ffmpegProcess.stdout.on('data',  (data) => {
      l(`STDOUT: ${data}`)
    });

    /** console output from stderr **/ // (progress comes through stderr for some reason)
    ffmpegProcess.stderr.on('data', (data) => {
      l(`STDERR: ${data}`)
    });

    /** whisper responds with 0 or 1 process code **/
    ffmpegProcess.on('close', (code) => {
      l(`child process exited with code ${code}`);
      if (code === 0) {
        resolve();
      } else {
        reject()
      }
    });
  })
}

async function getAudioCodec () {
  const ffprobeResponse = await ffprobe(inputVideoPath, { path: ffprobePath });

  l(ffprobeResponse);

  // get audio stream
  const audioStream = ffprobeResponse.streams.find(stream => stream.codec_type === 'audio');

  // get audio codec
  const audioCodec = audioStream.codec_name;

  // like .aac
  return audioCodec
}

async function main () {
  try {
    const audioCodec = await getAudioCodec();
    await extractAudio(inputVideoPath, `output-audio.${audioCodec}`);
  } catch (err) {
    l('err');
    l(err);
  }
}

main();

================
File: scripts/postAudioFile.js
================
const FormData = require('form-data');
const fs = require('fs-extra');
const axios = require('axios');

const l = console.log;

// TODO: should be able to hit any remote API
// TODO load it in like a list
const endpointToHit = 'http:localhost:3001/api'

function generateRandomNumber () {
  return Math.floor(Math.random() * 10000000000).toString();
}

async function hitRemoteApiEndpoint (form, fullApiEndpoint) {
  // use passed if available
  const endpointToUse = fullApiEndpoint || endpointToHit;

  const response = await axios.post(endpointToUse, form, {
    headers: {
      ...form.getHeaders(),
    },
  });

  return response
}

async function getNewData (dataUrl) {
  let dataResponse = await axios.get(dataUrl);

  l('dataResponse');
  l(dataResponse.data);
  return dataResponse.data
}

function checkResponse (dataResponse) {
  const transcriptionStatus = dataResponse?.status;

  const transcriptionComplete = transcriptionStatus === 'completed';
  const transcriptionErrored = transcriptionStatus === 'errored';

  const transcriptionIsTranslating = transcriptionStatus === 'translating';

  const transcriptionIsProcessing = transcriptionStatus === 'starting-transcription' ||
    transcriptionStatus === 'transcribing' || transcriptionStatus === 'processing' || transcriptionIsTranslating;

  if (transcriptionComplete) {
    const transcription = dataResponse?.transcription;
    const sdHash = dataResponse?.sdHash;
    const subtitles = dataResponse?.subtitles;
    const processingData = dataResponse?.processingData;

    return {
      status: 'completed',
      transcription,
      sdHash,
      subtitles,
      processingData,
    }
  }

  if (transcriptionIsProcessing) {
    const percentDone = dataResponse?.processingData?.progress;
    return {
      status: 'processing',
      percentDone
    }
  }

  if (transcriptionErrored) {
    return 'failed'
  }

  return false
}


const machineApiKey = '';

/**
 * Transcribe a file on a remote server
 * @param pathToAudioFile
 * @param language
 * @param model
 * @param websocketNumber
 */
async function transcribeRemoteServer (pathToAudioFile, language, model, websocketNumber, fullApiEndpoint) {
  // Create a new form instance
  const form = new FormData();

  // add the audio to the form as 'file'
  form.append('file', fs.createReadStream(pathToAudioFile));

  // load in language, model, and websocket number (which we have from the frontend)
  form.append('language', language);
  form.append('model', model);
  form.append('websocketNumber', websocketNumber);

  const response = await hitRemoteApiEndpoint(form, fullApiEndpoint);

  l('response');
  l(response);

  const dataEndpoint = response.data.transcribeDataEndpoint;

  return dataEndpoint;

}

const delayPromise = (delayTime) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, delayTime);
  });
};

async function getResult (dataEndpoint) {
  let dataResponse = await getNewData(dataEndpoint);
  let response = checkResponse(dataResponse);

  l('response');
  l(response);

  if (response.status === 'failed') {
    l('detected that failed')
    return {
      status: 'failed'
    }
  } else if (response.status === 'completed') {

    l('detected that completed')
    return {
      status: 'completed'
      // TODO: attach all the data
    }
  } else {
    l('detected that processing')
    await delayPromise(5000);
    return await getResult(dataEndpoint);
  }
}

/***
 * Allows a frontend to transcribe to via the API of a remote server
 * @param filePath
 * @param language
 * @param model
 * @param websocketNumber
 * @param fullApiEndpoint
 * @returns {Promise<void>}
 */
async function transcribeViaRemoteApi ({ filePath, language, model, websocketNumber, remoteServerApiUrl }) {
  const dataEndpoint = await transcribeRemoteServer(filePath, language, model, websocketNumber, remoteServerApiUrl);

  return await getResult(dataEndpoint)
}

async function realMain () {
  const filePath = './output-audio.aac';
  const language = 'Serbian';
  const model = 'tiny';
  const websocketNumber = generateRandomNumber()
  const remoteServerApiUrl = 'http://localhost:3001/api'
  const response = await transcribeViaRemoteApi({
    filePath,
    language,
    model,
    websocketNumber,
    remoteServerApiUrl
  });
  l('completed response');
  l(response);
}

realMain()

// main();

================
File: scripts/srtToVtt.js
================
let fs = require('fs-extra')
let convert = require('cyrillic-to-latin')
// const srt2vtt = Promise.promisifyAll(require('srt2vtt'));
const srt2vtt = require('srt2vtt')

const path = './public/translated.srt'

const filename = 'serbian';

l = console.log;

l(srt2vtt)


// function createTicket(ticket) {
//   // 1 - Create a new Promise
//   return new Promise(function (resolve, reject) {
//     // 2 - Copy-paste your code inside this function
//     client.tickets.create(ticket, function (err, req, result) {
//       // 3 - in your async function's callback
//       // replace return by reject (for the errors) and resolve (for the results)
//       if (err) {
//         reject(err);
//       } else {
//         resolve(JSON.stringify(result));
//       }
//     });
//   });
// }

function converSrtToVtt () {

}

async function main () {
  let data = await fs.readFile(path, 'utf8');

  data = convert(data);

  // l(data);
  // data = await srt2vtt(data);

  srt2vtt(data, async function (err, vttData) {
    l('running here');

    l(vttData);

    // vttData = convert(vttData);

    // l(vttData);

    if (err) throw new Error(err);
    l(data);

    fs.writeFileSync('./public/redone.vtt', vttData);
  });

  // l(data);
  // data = await convert(data);
  // l(data);
  // await fs.writeFile(data, `${path}/${filename}.mp4.vtt`, 'utf8')
}

main();
//
// fs.createReadStream(`${path}/${filename}.mp4.srt`)
//   .pipe(srt2vtt())
//   .pipe(convert())
//   .pipe(fs.createWriteStream(`${path}/${filename}.mp4.vtt`))

================
File: transcribe/transcribe-api-wrapped.js
================
const which = require('which');
const spawn = require('child_process').spawn;
const { handleStdErr, handleStdOut, handleProcessClose } = require('../lib/transcribing')

const {
  buildArguments,
} = require('./transcribing');

l = console.log;

const whisperPath = which.sync('whisper')

async function transcribe ({
  language,
  model,
  originalFileExtension,
  uploadFileName,
  originalFileName,
  uploadFilePath,
  numberToUse, // random or websocket number (websocket if being used from frontend)
}) {
  return new Promise(async (resolve, reject) => {
    try {
      // where app.js is running from
      const processDir = process.cwd()

      // original upload file path
      const originalUpload = `${processDir}/uploads/${uploadFileName}`;

      //
      const processingDataPath = `${processDir}/transcriptions/${numberToUse}/processing_data.json`

      // save date when starting to see how long it's taking
      const startingDate = new Date();
      l(startingDate);

      const whisperArguments = buildArguments({
        uploadedFilePath: uploadFilePath, // file to use
        language, //
        model,
        numberToUse,
      })

      l('whisperArguments');
      l(whisperArguments);

      // start whisper process
      const whisperProcess = spawn(whisperPath, whisperArguments);

      // TODO: implement foundLanguagae here
      // let foundLanguage;
      whisperProcess.stdout.on('data',  (data) => l(`STDOUT: ${data}`));

      /** console output from stderr **/ // (progress comes through stderr for some reason)
      whisperProcess.stderr.on('data', handleStdErr({ model, language, originalFileName, processingDataPath }));

      /** whisper responds with 0 or 1 process code **/
      whisperProcess.on('close', handleProcessClose({ processingDataPath, originalUpload, numberToUse }))


    } catch (err) {
      l('error from transcribe')
      l(err);

      reject(err);

      throw new Error(err)
    }

  });

}

module.exports = transcribe;

================
File: transcribe/transcribe-via-api.js
================
const servers = [{
  sslHostnameAndPort : 'localhost:8080',
  processAmount: 2,
}]

async function startTranscription () {
  const audioFile = './ljubav.mp3';


}

async function transcribeViaApi () {
  const audioFile = './ljubav.mp3';



}

================
File: transcribe/transcribe-wrapped.js
================
const which = require('which');
const spawn = require('child_process').spawn;
const fs = require('fs-extra');
const ffprobe = require('ffprobe');
const WebSocket = require('ws');
const path = require('path');
const projectConstants = require('../constants/constants');
const { shouldTranslateFrom, languagesToTranscribe, translationLanguages, getLanguageCodeForAllLanguages } = projectConstants;
const forHumans = require('../helpers/helpers').forHumans;
const createTranslatedFiles = require('../translate/create-translated-files');
const multipleGpusEnabled = process.env.MULTIPLE_GPUS === 'true';
const { formatStdErr } = require('../helpers/formatStdErr')
const { convertChineseTraditionalToSimplified, convertSerbianCyrillicToLatin } = require('../lib/convertText');
const { stripOutTextAndTimestamps } = require('../translate/helpers')
const { updateQueueItemStatus } = require('../queue/queue');
// const {amountOfRunningJobs} = require("../queue/newQueue");
const maxConcurrentJobs = Number(process.env.CONCURRENT_AMOUNT);

function amountOfRunningJobs () {
  let amount = 0;
  for (let processNumber in global.jobProcesses) {
    const propValue = global.jobProcesses[processNumber];

    if (propValue !== undefined) {
      amount++;
    }
  }

  return amount;
}

const l = console.log;

const concurrentAmount = process.env.CONCURRENT_AMOUNT;
const nodeEnvironment = process.env.NODE_ENV;
const libreTranslateHostPath = process.env.LIBRETRANSLATE;

// l(`libreTranslateHostPath: ${libreTranslateHostPath}`)

const isProd = nodeEnvironment === 'production';

const whisperPath = which.sync('whisper')

global.transcriptions = [];

function sendToWebsocket (websocketConnection, data) {
  websocketConnection.send(JSON.stringify(data), function () {});
}

async function transcribe ({
  uploadedFilePath,
  language,
  model,
  websocketConnection,
  websocketNumber,
  directorySafeFileNameWithoutExtension,
  directorySafeFileNameWithExtension,
  originalFileNameWithExtension,
  fileSafeNameWithDateTimestamp,
  fileSafeNameWithDateTimestampAndExtension,
  uploadGeneratedFilename,
  shouldTranslate,
  uploadDurationInSeconds,
  fileSizeInMB,
  user,
  downloadLink,
  // totalOutstanding, // not actually useful
  processNumber,
}) {
  return new Promise(async (resolve, reject) => {

    function webSocketIsStillAlive (webSocketNumber) {
      return global.webSocketData.some(item => item.websocketNumber === webSocketNumber);
    }

    // if the upload was removed from the queue, don't run it
    if (webSocketIsStillAlive(websocketNumber) === false) {
      l('DIDNT HAVE THE QUEUE DATA MATCH, ABORTING');
      // if they're not in the queue, cut them off
      // TODO: change to reject?
      updateQueueItemStatus(websocketNumber, 'abandoned');
      return reject('WEBSOCKET DISCONNECTED');
    }

    try {

      // inform frontend their processing has started
      sendToWebsocket(websocketConnection, {
        message: 'starting',
        text: 'Whisper initializing, updates to come...'
      })
      updateQueueItemStatus(websocketNumber, 'processing');

      // fixes bug with windows
      const osSpecificPathSeparator = path.sep;

      // get the upload file name
      // the ugly generated file id made the during the upload (for moving the upload over)
      let uploadFolderFileName = uploadedFilePath.split(osSpecificPathSeparator).pop();

      const originalUpload = `./uploads/${uploadFolderFileName}`;

      const uploadDurationInSecondsHumanReadable = forHumans(uploadDurationInSeconds);

      const fileDetailsJSON = {
        filename: directorySafeFileNameWithExtension,
        language,
        model,
        uploadDurationInSeconds,
        uploadDurationInSecondsHumanReadable,
      }

      let displayLanguage;
      if (language === 'auto-detect') {
        displayLanguage = 'Auto-Detect';
      } else {
        displayLanguage = language;
      }

      // just do JSON, then loop through properties on the frontend
      let fileDetails = `
            Filename: ${directorySafeFileNameWithExtension}
            Language: ${displayLanguage}
            Model: ${model}
            Upload Duration: ${uploadDurationInSecondsHumanReadable}
      `.replace(/^ +/gm, ''); // remove indentation

      // update filedetails
      websocketConnection.send(JSON.stringify({
        message: 'fileDetails',
        fileDetails
      }), function () {});

      /** INSTANTIATE WHISPER PROCESS **/
      // queue up arguments, path is the first one
      let arguments = [uploadedFilePath];

      const languageIsAutoDetect = language === 'auto-detect';

      // don't pass a language to use auto-detect
      if (!languageIsAutoDetect) {
        arguments.push('--language', language);
      }

      // set the language for whisper (if undefined with auto-detect and translate off that)
      if (model) {
        arguments.push('--model', model);
      }

      // alternate
      // todo: do an 'express' queue and a 'large files' queue
      if (isProd && multipleGpusEnabled) {
        if (topLevelValue === 1) {
          arguments.push('--device', 'cuda:0');
        } else if (topLevelValue === 2) {
          arguments.push('--device', 'cuda:1');
        }
      }

      // dont show the text output but show the progress thing
      arguments.push('--verbose', 'False');

      // folder to save .txt, .vtt and .srt
      arguments.push('-o', 'transcriptions/' + uploadGeneratedFilename);

      l('transcribe arguments');
      l(arguments);

      const whisperProcess = spawn(whisperPath, arguments);

      // TODO: rename
      let serverNumber = processNumber

      // add process globally to kill it when user leaves
      const process = {
        websocketNumber,
        spawnedProcess: whisperProcess,
        serverNumber,
        type: 'transcription',
      }
      global.transcriptions.push(process)

      // find auto-detected language
      let foundLanguage;

      //  console output from stdoutt
      whisperProcess.stdout.on('data', data => {
        websocketConnection.send(JSON.stringify(`stdout: ${data}`), function () {});
        l(`STDOUT: ${data}`);

        // TODO: pull this out into own function
        // check if language is autodetected)
        const dataAsString = data.toString();
        if (dataAsString.includes('Detected language:')) {

          // parse out the language from the console output
          foundLanguage = dataAsString.split(':')[1].substring(1).trimEnd();

          l(`DETECTED LANGUAGE FOUND: ${foundLanguage}`);
          if (language === 'auto-detect' && foundLanguage) {
            language = foundLanguage
            displayLanguage = `${language} (Auto-Detected)`
          }

          // send data to frontend with updated language
          // TODO: when it's JSON, just add the detected language here as a property
          fileDetails = `
            Filename: ${directorySafeFileNameWithExtension}
            Language: ${displayLanguage}
            Model: ${model}
            Upload Duration: ${uploadDurationInSecondsHumanReadable}
          `.replace(/^ +/gm, ''); // remove indentation

          // update file details
          websocketConnection.send(JSON.stringify({
            message: 'fileDetails',
            fileDetails
          }), function () {});
        }
      });

      // log output from bash (it all comes through stderr for some reason?)
      whisperProcess.stderr.on('data', data => {
        const currentlyRunningJobs = amountOfRunningJobs();
        const amountInQueue = global.newQueue.length
        const totalOutstanding = currentlyRunningJobs + amountInQueue;

        let outputString = `
         STDERR: ${data},
         Duration: ${uploadDurationInSecondsHumanReadable},
         Model: ${model}, 
         Language: ${displayLanguage},
         Filename: ${directorySafeFileNameWithExtension}, 
         Queue: ${totalOutstanding}, 
         Translating: ${shouldTranslate}`;

        outputString = outputString.replace(/\s+/g, ' ');
        l(outputString);



        // loop through and do with websockets
        for (let [, websocket] of global['webSocketData'].entries() ) {
          const websocketConnection = websocket.websocket;
          const clientWebsocketNumber = websocket.websocketNumber;
          const websocketFromProcess = websocketNumber;

          let ownershipPerson = 'others'
          if (clientWebsocketNumber === websocketFromProcess) {
            ownershipPerson = 'you'
          }

          const formattedProgress = formatStdErr(data.toString());
          // l('formattedProgress');
          // l(formattedProgress);

          const { percentDoneAsNumber, percentDone, speed, timeRemaining  } = formattedProgress;

          let processingString = '';
          if (timeRemaining) {
            processingString = `[${percentDone}] ${timeRemaining.string} Remaining, Speed ${speed}f/s`
          }

          // TODO: pull into function
          // pass latest data to all the open sockets
          if (websocketConnection.readyState === WebSocket.OPEN) {
            /** websocketData message **/
            websocketConnection.send(JSON.stringify({
              message: 'websocketData',
              processingData: processingString,
              // processingData: data.toString(),
              ownershipPerson,
              serverNumber, // on the frontend we'll react different if it's on server 1 or two
              formattedProgress,
              percentDone: percentDoneAsNumber,
              timeRemaining,
              speed,
            }));
          }
        }
      });


      // save date when starting to see how long it's taking
      const startingDate = new Date();
      l(startingDate);

      /** AFTER WHISPER FINISHES, DO THE FILE MANIPULATION / TRANSLATION **/
      whisperProcess.on('close', async (code) => {
        try {
          l('code');
          l(code);

          if (!language || language === 'auto-detect') {
            language = foundLanguage;
          }

          const processFinishedSuccessfully = code === 0

          // successful output
          if (processFinishedSuccessfully) {
            // TODO: pull out all this moving stuff into its own function

            const originalContainingDir = `./transcriptions/${uploadGeneratedFilename}`;

            const originalDirectoryAndNewFileName = `${originalContainingDir}/${directorySafeFileNameWithoutExtension}`

            await fs.move(originalUpload, `${originalContainingDir}/${directorySafeFileNameWithExtension}`, { overwrite: true })

            // turn this to a loop
            /** COPY TO BETTER NAME, SRT, VTT, TXT **/
            const transcribedSrtFilePath = `${originalDirectoryAndNewFileName}.srt`;

            const transcribedVttFilePath = `${originalDirectoryAndNewFileName}.vtt`;

            const transcribedTxtFilePath = `${originalDirectoryAndNewFileName}.txt`;

            // copy srt with the original filename
            // SOURCE, ORIGINAL
            // TODO: could probably move here instead of copy
            await fs.move(`${originalContainingDir}/${uploadFolderFileName}.srt`, transcribedSrtFilePath, { overwrite: true })

            await fs.move(`${originalContainingDir}/${uploadFolderFileName}.vtt`, transcribedVttFilePath, { overwrite: true })

            await fs.move(`${originalContainingDir}/${uploadFolderFileName}.txt`, transcribedTxtFilePath, { overwrite: true })

            // convert Serbian text from Cyrillic to Latin
            if (language === 'Serbian') {
              await convertSerbianCyrillicToLatin({ transcribedSrtFilePath, transcribedVttFilePath, transcribedTxtFilePath })
            }

            // convert Chinese characters to Simplified
            if (language === 'Chinese') {
              await convertChineseTraditionalToSimplified({ transcribedSrtFilePath, transcribedVttFilePath, transcribedTxtFilePath })
            }

            updateQueueItemStatus(websocketNumber, 'completed');

            // return await so queue moves on, don't need to wait for translations
            resolve(code);

            l(`should translate: ${shouldTranslate}`)

            const vttPath = `${originalDirectoryAndNewFileName}.vtt`;

            // copy original as copied
            await fs.copy(vttPath, `${originalDirectoryAndNewFileName}_${language}.vtt`)

            // strip out text and timestamps here to save in processing_data.json
            const { strippedText, timestampsArray } = await stripOutTextAndTimestamps(vttPath)

            let translationStarted, translationFinished = false;
            /** TRANSLATION FUNCTIONALITY **/
            if (libreTranslateHostPath, shouldTranslate) {
              // tell frontend that we're translating now
              websocketConnection.send(JSON.stringify({
                languageUpdate: 'Doing translations with LibreTranslate',
                message: 'languageUpdate'
              }), function () {});
              l('hitting LibreTranslate');
              translationStarted = true;
              // hit libretranslate
              await createTranslatedFiles({
                directoryAndFileName: originalDirectoryAndNewFileName,
                language,
                websocketConnection,
                strippedText,
                timestampsArray
              })
              translationFinished = true;
            }

            // just post-processing, you can return the response
            const processingSeconds = Math.round((new Date() - startingDate) / 1000);

            const processingRatio = (uploadDurationInSeconds/processingSeconds).toFixed(2);

            // TODO: just have a function called "sendFileInfoToClient(fileInfoJSON)"
            const outputText = `
            filename: ${originalFileNameWithExtension}
            processingSeconds: ${processingSeconds}
            processingSecondsHumanReadable: ${forHumans(processingSeconds)}
            language: ${language}
            model: ${model}
            upload: ${uploadFolderFileName}
            uploadDurationInSeconds: ${uploadDurationInSeconds}
            uploadDurationInSecondsHumanReadable: ${forHumans(uploadDurationInSeconds)}
            processingRatio: ${processingRatio}
            startedAt: ${startingDate.toUTCString()}
            finishedAT: ${new Date().toUTCString()}
          `.replace(/^ +/gm, ''); // remove indentation

            // tell frontend upload is done
            websocketConnection.send(JSON.stringify({
              status: 'Completed',
              urlSrt: transcribedSrtFilePath,
              urlVtt: transcribedVttFilePath,
              urlTxt: transcribedTxtFilePath,
              filename: fileSafeNameWithDateTimestamp,
              detailsString: outputText
            }), function () {});

            const translationStartedAndCompleted = translationStarted && translationFinished;

            let translatedLanguages = [];
            if (translationStartedAndCompleted) {
              // TODO: this is named wrong, should be languagesToTranslateTo
              // remove the original language from languagesToTranslateTo
              translatedLanguages = languagesToTranscribe.filter(e => e !== language);
            }

            const wordCount = strippedText.split(' ').length;
            const wordsPerMinute = Math.round(wordCount / (uploadDurationInSeconds / 60));

            // data to save to processing_data.json
            const fileDetailsObject = {
              filename: originalFileNameWithExtension,
              processingSeconds,
              processingSecondsHumanReadable: forHumans(processingSeconds),
              language,
              languageCode: getLanguageCodeForAllLanguages(language),
              model,
              upload: uploadFolderFileName,
              uploadDurationInSeconds,
              uploadDurationInSecondsHumanReadable,
              processingRatio,
              startedAt: startingDate.toUTCString(),
              finishedAT: new Date().toUTCString(),
              status: 'completed',
              translatedLanguages,
              fileExtension: path.parse(originalFileNameWithExtension).ext,
              directoryFileName: directorySafeFileNameWithoutExtension,
              strippedText,
              timestampsArray,
              wordCount,
              wordsPerMinute,
              fileSizeInMB,
              characterCount: strippedText.length,
            }

            if (downloadLink) fileDetailsObject.downloadLink = downloadLink;
            if (user) fileDetailsObject.user = user;

            // save processing_data.json
            await fs.appendFile(`${originalContainingDir}/processing_data.json`, JSON.stringify(fileDetailsObject), 'utf8');

            // TODO: if no link passed, because if link was passed no need to rename directory
            const renamedDirectory = `./transcriptions/${fileSafeNameWithDateTimestamp}`;
            await fs.rename(originalContainingDir, renamedDirectory)

            function matchByWebsocketNumber (item) {
              return item.websocketNumber === websocketNumber;
            }

            function removeFromArrayByWebsocketNumber (array) {
              const index = array.findIndex(matchByWebsocketNumber);
              if (index > -1) {
                array.splice(index, 1);
              }
            }

            removeFromArrayByWebsocketNumber(global.transcriptions, websocketNumber);


          } else {
            l('FAILED!');
            reject();
            throw new Error('Transcription has been ended')
          }

          l(`child process exited with code ${code}`);
        } catch (err) {
          updateQueueItemStatus(websocketNumber, 'errored');

          reject(err);
          l('websocket connection');
          // if websocket is still connected
          if (websocketConnection.readyState === 1) {
            sendToWebsocket({
              message: 'error',
              text: 'The transcription failed, please try again or try again later'
            })
            websocketConnection.terminate()
          }
          l('err here');
          l(err.stack);
          l(err);
          throw err;
        }
      });
      // TODO: this doesn't seem to actually work (errors never seem to land here)
    } catch (err) {
      l('error from transcribe-wrapped')
      l(err);

      updateQueueItemStatus(websocketNumber, 'errored');

      websocketConnection.send(JSON.stringify({
        message: 'error',
        text: 'The transcription failed, please try again or try again later'
      }), function () {});
      reject(err);

      throw err;
    }

  });

}

module.exports = transcribe;

================
File: transcribe/transcribing.js
================
const fs = require('fs-extra');
const createTranslatedFiles = require('../translate/create-translated-files');
const {forHumans} = require('../helpers/helpers');

// TODO: move to another directory
const outputFileExtensions = ['.srt', '.vtt', '.txt']

const nodeEnvironment = process.env.NODE_ENV;
const libreTranslateHostPath = process.env.LIBRETRANSLATE;

const isProd = nodeEnvironment === 'production';

function buildArguments ({
  uploadedFilePath,
  language,
  model,
  numberToUse
}) {
  /** INSTANTIATE WHISPER PROCESS **/
    // queue up arguments, path is the first one
  let arguments = [];

  // first argument is path to file
  arguments.push(uploadedFilePath);

  // these don't have to be defined
  if (language) arguments.push('--language', language);
  if (model) arguments.push('--model', model);

  // dont show the text output but show the progress thing
  arguments.push('--verbose', 'False');

  // folder to save .txt, .vtt and .srt
  arguments.push('-o', `transcriptions/${numberToUse}`);

  l('transcribe arguments');
  l(arguments);

  return arguments
}

async function translateIfNeeded ({ language, shouldTranslate, processingDataPath, directoryAndFileName}) {
  const shouldTranslateFromLanguage = shouldTranslateFrom(language);
  l(`should translate from language: ${shouldTranslateFromLanguage}`)
  l(`libreTranslateHostPath: ${libreTranslateHostPath}`)
  l(`should translate: ${shouldTranslate}`)

  let translationStarted, translationFinished = false;
  /** AUTOTRANSLATE WITH LIBRETRANSLATE **/
  if (libreTranslateHostPath && shouldTranslateFromLanguage && shouldTranslate) {
    l('hitting LibreTranslate');
    translationStarted = new Date();
    // hit libretranslate
    await createTranslatedFiles({
      directoryAndFileName,
      language,
    })

    await writeToProcessingDataFile(processingDataPath, {
      translationStartedAt: new Date(),
      status: 'translating',
    })
  }
}

async function saveTranscriptionCompletedInformation ({
  startingDate,
  sdHash
}) {
  const processingDataPath = `./transcriptions/${sdHash}/processing_data.json`;

  // just post-processing, you can return the response
  const processingSeconds = Math.round((new Date() - startingDate) / 1000);

  await writeToProcessingDataFile(processingDataPath, {
    processingSeconds,
    processingSecondsHumanReadable: forHumans(processingSeconds),
    startedAt: startingDate.toUTCString(),
    finishedAT: new Date().toUTCString(),
  })
}

async function moveAndRenameFilesAndFolder ({
  originalUpload,
  uploadFileName,
  sdHash,
  originalFileExtension,
}) {
  const originalUploadPath = originalUpload;

  // the directory with the output from whisper
  let currentContainingDir = `./transcriptions/${sdHash}`;

  const newUploadPath = `${currentContainingDir}/${sdHash}${originalFileExtension}`

  // rename original upload to use the original file upload name
  await fs.move(originalUploadPath, newUploadPath)

  // move each of the different output files
  for (const fileExtension of outputFileExtensions) {
    // create the prepend thing to loop over
    const transcribedFilePath = `${currentContainingDir}/${uploadFileName}${fileExtension}`
    const newTranscribedFilePath = `${currentContainingDir}/${sdHash}${fileExtension}`

    // rename
    await fs.move(transcribedFilePath, newTranscribedFilePath)
  }

  // rename containing dir to the safe filename (from upload filename)
  // const renamedDirectory = `./transcriptions/${sixDigitNumber}`;
  // await fs.rename(currentContainingDir, renamedDirectory)
}

module.exports = {
  moveAndRenameFilesAndFolder,
  saveTranscriptionCompletedInformation,
  translateIfNeeded,
  buildArguments,
  // autoDetectLanguage,
  // writeToProcessingDataFile
}

================
File: translate/create-translated-files.js
================
// const translateText = require('./libreTranslateWrapper');
const fs = require('fs-extra');
// TODO: this is named wrong, should be languagesToTranslateTo
const { languagesToTranscribe, allLanguages } = require('../constants/constants');;
const { reformatVtt } = require('./helpers')
const { simplified } = require('zh-convert');
const translateText = require('./google-translate-browser')

const convert = require('cyrillic-to-latin');

let l = console.log;

if (global.debug === 'false') {
  l = function () {}
}

// l('translationLanguages')
// l(translationLanguages);
//
// l('languagesToTranscribe')
// l(languagesToTranscribe);

// l('all languages');
// l(allLanguages);

function getCodeFromLanguageName (languageName) {
  return allLanguages.find(function (filteredLanguage) {
    return languageName === filteredLanguage.name;
  }).code
}

// l(getCodeFromLanguageName('English'))
// TODO: pass processing path
/** for translation **/
async function createTranslatedFiles ({
    directoryAndFileName,
    language,
    websocketConnection,
    strippedText,
    timestampsArray,
}) {

  const loopThrough = ['.srt', '.vtt', 'txt'];

  const vttPath = `${directoryAndFileName}.vtt`;

  // TODO: translate the rest
  const vttData = await fs.readFile(vttPath, 'utf-8');
  l('vttData');
  l(vttData);

  // TODO: pass this in from controller?
  // const { strippedText, timestampsArray } = await stripOutTextAndTimestamps(vttPath)

  // save stripped and timestamps to processing data

  l({languagesToTranscribe})


  for (const languageToConvertTo of languagesToTranscribe) {
    l('languageToConvertTo');
    l(languageToConvertTo);

    l('language');
    l(language);

    try {
      // no need to translate just copy the file
      if (languageToConvertTo !== language) {
        websocketConnection.send(JSON.stringify({
          languageUpdate: `Translating into ${languageToConvertTo}..`,
          message: 'languageUpdate'
        }), function () {});


        const sourceLanguageCode = getCodeFromLanguageName(language);
        const targetLanguageCode = getCodeFromLanguageName(languageToConvertTo);

        // l('sourceLanguageCode');
        // l(sourceLanguageCode);
        // l('targetLanguageCode');
        // l(targetLanguageCode);

        // hit LibreTranslate backend
        l(`hitting libretranslate: ${language} -> ${languageToConvertTo}`);
        // TODO: to convert to thing
        // let translatedText = await translateText({
        //   sourceLanguage: sourceLanguageCode, // before these were like 'EN', will full language work?
        //   targetLanguage: targetLanguageCode,
        //   text: strippedText,
        // })

        let translatedText = await translateText({
          text: strippedText,
          targetLanguageCode, // before these were like 'EN', will full language work?
        })
        // l('translatedText');
        // l(translatedText);

        if (!translatedText) {
          continue
        }

        if (languageToConvertTo === 'Chinese') {
          translatedText = simplified(translatedText);
        }

        if (languageToConvertTo === 'Serbian') {
          translatedText = convert(translatedText);
        }

        const reformattedVtt = reformatVtt(timestampsArray, translatedText);

        await fs.writeFile(`${directoryAndFileName}_${languageToConvertTo}.vtt`, reformattedVtt, 'utf-8');
      }
    } catch (err) {
      l(err);
      l('error in translation');
      return err
    }
  }
}

// const uploadDirectoryName = 'ef56767d5cba0ae421a9f6f570443205';
// const transcribedFileName = 'ef56767d5cba0ae421a9f6f570443205';
//
// const languageToConvertFrom = 'en';
// const languagesToConvertTo = ['es', 'fr'];

// async function main(){
//   const completed = await createTranslatedSrts({
//     uploadDirectoryName: uploadDirectoryName,
//     transcribedFileName: transcribedFileName,
//     languageToConvertFrom: languageToConvertFrom,
//     languagesToConvertTo: languagesToConvertTo
//   });
//
//   l('completed');
//   l(completed);
// }

// main();

module.exports = createTranslatedFiles;

================
File: translate/google-translate-browser.js
================
const { generateRequestUrl, normaliseResponse } = require('google-translate-api-browser');
const axios = require('axios');

const l = console.log;

const maximumStringLength = 3000;

function splitString (str) {
  let splitStrings = [];
  let currentString = '';
  const splitString = str.split('\n');

  l('total lines')
  l(splitString.length);

  // TODO: if this was smarter it wouldn't go over 5000 characters,
  // TODO: but it seems to be fine for now
  let counter = 0;
  for (const string of splitString) {
    counter++
    // we have yet to encounter the maximum string length
    if (currentString.length < maximumStringLength) {
      // l('not too long')
      currentString = `${currentString}${string}\n`


      if (counter === splitString.length) {
        splitStrings.push(currentString);
      }
      // currentString = currentString + string + '\n';
    } else {
      l('too long')
      currentString = `${currentString}${string}\n`
      splitStrings.push(currentString);
      currentString = '';
    }
  }
  return splitStrings;
}

function test () {
  const textToTranslate = `Znači tako.
    Tako.
    Vi znate šta vam sleduje?
    Nemamo pojma, to ne piše nigde u pravilniku.
    Od sad ćete razgovarati sa višim instansama.
    Ko je idejni vođa ovog protesta?
    Ja sam.
    Pa, šta da kažem.
    Možda i nije najpametnije što sam to uradila, ali...
    `

  const chunks = splitString(textToTranslate);

  l('chunks');
  l(chunks.length);
  // for(const chunk of chunks) {
  //   l(chunk);
  // }
  // l(chunks);

  let recombined = '';
  for (const chunk of chunks) {
    recombined = recombined + chunk;
  }

  l('recombined');
  l(recombined.length);
  // l(recombined)

  // l(textToTranslate)

  // const chunks = splitString(textToTranslate);
  //
  // l('chunks', chunks);

  const resplit = recombined.split('\n');
  l('resplit');
  l(resplit.length);
// l(textToTranslate.split('\n').length));
}



async function translateText ({ text, targetLanguageCode }) {
  const url = generateRequestUrl(text, { to: targetLanguageCode });
  // l('generated url');
  // l(url);

  let response;
  try {
    response = await axios.get(url);

    const parsedResponse = normaliseResponse(response.data);
    // l('parsedResponse');
    // l(parsedResponse);

    const translatedText = parsedResponse.text;
    // l('translatedText');
    // l(translatedText);

    return translatedText;
  } catch (error) {
    l('errored');
    // l('error', error);
  }
}

async function splitAndTranslateText ({ text, targetLanguageCode }) {
  const chunks = splitString(text);
  l('chunks');
  l(chunks.length);

  let translatedText = '';
  for (const chunk of chunks) {
    const translatedChunk = await translateText({ text: chunk, targetLanguageCode });
    translatedText = translatedText + translatedChunk + '\n';
  }

  return translatedText;
}

function howManyLines (string) {
  return string.split('\n').length;
}

const delayPromise = (delayTime) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, delayTime);
  });
};

async function newMain () {
  await delayPromise(1000);

  let totalTranslatedText = '';
  for (const chunk of chunks) {
    l('\n\n')
    l('chunk');
    l(chunk);

    const translated = await translateText({
      text: chunk,
      targetLanguageCode: 'en'
    });

    l('translated');
    l(translated)
    l('\n\n')

    totalTranslatedText = totalTranslatedText + translated + '\n';
  }

  l('totalTranslatedText');
  l(totalTranslatedText);

  l('how many lines');
  l(howManyLines(totalTranslatedText));
  l(howManyLines(textToTranslate));
  l(howManyLines(recombined));

  l('totalTranslatedText');
  l(totalTranslatedText);
  l('textToTranslate');
  l(textToTranslate);
}

// newMain()

async function main () {
  try {
    const translated = await translateText({
      text: textToTranslate,
      targetLanguageCode: 'en'
    });

    // l('translated');
    // l(translated);
  } catch (err) {
    l('err');
    l(err);
  }
}

// main();

module.exports = splitAndTranslateText;

================
File: translate/helpers.js
================
const fs = require('fs-extra');
const readline = require('readline');

l = console.log;


function isTimestampLine (num) {
  return (num - 3) % 3 === 0;
}

function isTextLine (num) {
  return num !== 1 && ((num - 1) % 3 === 0);
}


const srtPath = '../examples/dnevnik.srt'

let topLevelValue = 1;
async function stripOutTextAndTimestamps (filePath, readableStream) {
  return new Promise(async (resolve, reject) => {
    let rl;
    if (readableStream) {
      rl = await readline.createInterface({
        input: filePath
      });
    } else {
      rl = readline.createInterface({
        input: fs.createReadStream(filePath, 'utf8')
      });
    }

    let strippedText = '';
    let timestampsArray = [];

    let counter = 1;
    rl.on('line', (line) => {
      // l(counter)
      // l(line);
      const timestampLine = isTimestampLine(counter)
      const textLine = isTextLine(counter)
      // l('is timestamp line', timestampLine)
      // l('is text line', textLine)
      // l(`\n\n`)
      if (textLine) {
        strippedText = strippedText + `${line}\n`
      }
      if (timestampLine) {
        timestampsArray.push(line)
      }
      counter++
    });

    rl.on('close', async function () {
      l('\n\n')
      resolve({
        strippedText,
        timestampsArray
      })
    })

    rl.on('error', function (err) {
      reject(err)
    });

  });

}

// async function main(){
//   const { strippedText, timestampsArray } = await stripOutTextAndTimestamps(srtPath)
//   l(strippedText);
//   l(timestampsArray);
// }

// main();

const timestampArray = [
  '00:00.000 --> 00:24.860',
  '00:24.860 --> 00:34.860',
  '00:34.860 --> 00:44.860',
  '00:44.860 --> 00:52.860',
  '00:52.860 --> 01:04.860'
];

const translatedText = 'Good day. I\'m Mirela Vasin, and this is the News of the Day.\n' +
  'A Serb, a former member of the Kosovo Police, was arrested in spring. Serbs began to gather and set up barricades.\n' +
  'Prime Minister Anna Brnabić appealed to the International Community not to turn its head away from the human rights of Serbs in Kosmet.\n' +
  'Ukraine asks for additional weapons, Moscow warns of consequences.\n' +
  'Today, two quarter-final matches are being played at the world football championship - Morocco-Portugal and England-France.'


function reformatVtt (timestampArray, translatedText) {
  // l('timestampArray')
  // l(timestampArray);

  const splitText = translatedText.split('\n').slice(0, -1);
  l(splitText)

  let formattedVtt = 'WEBVTT\n';

  for (const [index, value] of splitText.entries()) {
    formattedVtt = formattedVtt + `\n${timestampArray[index]}\n${value}\n`
  }

  return formattedVtt
}

module.exports = {
  stripOutTextAndTimestamps,
  reformatVtt
}

// async function main(){
//   const { strippedText, timestampsArray } = await stripOutTextAndTimestamps(srtPath)
//   l(strippedText);
//   l(timestampsArray);
//
//   const formattedVtt = reformatVtt(timestampsArray, translatedText)
//   l(formattedVtt)
// }
//
// main();

================
File: translate/libreTranslateWrapper.js
================
const fetch = require('node-fetch');
const l = console.log;

// TODO: replace this with new instance
const LTHost = process.env.LIBRETRANSLATE;

// l('LTHost');
// l(LTHost)

const endpoint = LTHost + '/translate';

// l('endpoint');
// l(endpoint)


process.on('unhandledRejection', (reason, promise) => {
  l(reason);
  l(promise);
});

async function hitLTBackend ({ text, sourceLanguage, targetLanguage }) {
  const res = await fetch(endpoint, {
    method: 'POST',
    body: JSON.stringify({
      q: text,
      source: sourceLanguage,
      target: targetLanguage
    }),
    headers: { 'Content-Type': 'application/json' }
  });

  return await res.json()
}

async function translateText ({ text, sourceLanguage, targetLanguage }) {
  const translatedResponse = await hitLTBackend({ text, sourceLanguage, targetLanguage });
  // l(translatedResponse);

  const { translatedText, detectedLanguage } = translatedResponse;
  return translatedText;
}

// /** all languages should be as abbreviation **/
//
// // translate from this language
// const sourceLanguage = 'auto';
//
// // into this language
// const targetLanguage = 'es';
//
// const text = 'This is the text I want to translate';
//
// // translate({ text, sourceLanguage, targetLanguage });
//
// async function main(){
//   const translatedText = await translateText({ text, sourceLanguage, targetLanguage });
//   l('translatedText');
//   l(translatedText);
// }
//
// // main();

module.exports = translateText;

================
File: translate/translate-files-api.js
================
const translateText = require('./libreTranslateWrapper');
const fs = require('fs-extra');
const projectConstants = require('../constants/constants');
const { languagesToTranscribe, translationLanguages } = projectConstants;

// const languagesToTranscribe = {}

let l = console.log;

// l('languages to transcribe');
// l(languagesToTranscribe)
// [ 'English', 'French', 'German', 'Spanish', 'Russian', 'Japanese' ]

if (global.debug === 'false') {
  l = function () {}
}

function getCodeFromLanguageName (languageName) {
  return translationLanguages.find(function (filteredLanguage) {
    return languageName === filteredLanguage.name;
  }).code
}

/** for translation **/
async function createTranslatedFiles ({
  directoryAndFileName,
  language,
}) {
  const webVttData = await fs.readFile(`${directoryAndFileName}.vtt`, 'utf-8');

  // copy original as copied
  await fs.copy(`${directoryAndFileName}.vtt`, `${directoryAndFileName}_${language}.vtt`)

  for (const languageToConvertTo of languagesToTranscribe) {
    l('languageToConvertTo');
    l(languageToConvertTo);

    l('language');
    l(language);

    try {
      // no need to translate just copy the file
      if (languageToConvertTo !== language) {
        // hit LibreTranslate backend
        l(`hitting libretranslate: ${language} -> ${languageToConvertTo}`);

        let translatedText = await translateText({
          sourceLanguage: getCodeFromLanguageName(language), // before these were like 'EN', will full language work?
          targetLanguage: getCodeFromLanguageName(languageToConvertTo),
          text: webVttData,
        })

        // do the regexp here
        translatedText.replace(/^(\d[\d:.]+\d) .*?( \d[\d:.]+\d)$/gm, '$1 -->$2');

        translatedText = 'WEBVTT' + translatedText.slice(6);

        await fs.writeFile(`${directoryAndFileName}_${languageToConvertTo}.vtt`, translatedText, 'utf-8');
      }
    } catch (err) {
      l(err);
      l('error in translation');
      return err
    }
  }
}

module.exports = createTranslatedFiles;

================
File: views/addTranslation/addTranslation.pug
================
extends ../layout

block content

    h2= title
    form(action=`/player/` + renderedFilename + `/add` method='post')
        input(type='text', name="language" placeholder="Language" value="English")
        br
        textarea#message(name='message' rows='40' cols='100' value="Hello World")
        br
        input(type='submit' value='Submit')

    script.
      $(document).ready(function() {

      });
      // const originalVtt = `#{originalVtt}`
      // document.getElementById('message').innerHTML = originalVtt;

================
File: views/index/components/amounts-header.pug
================
style.
  input[type=file], /* FF, IE7+, chrome (except button) */
  input[type=file]::-webkit-file-upload-button { /* chromes and blink button */
    cursor: pointer;
  }

if isFreeSubtitles
  .firstHeader
    a(href='/' target='_blank' style="text-decoration: none;")
      h1 FreeSubtitles.AI
    .transcribedStats
      h3.amountsHeader #{siteStats.amountOfTranscriptions} transcriptions completed
      h3.amountsHeader #{siteStats.humanReadableTime} transcribed
    //.fileLimitsDiv
    //  h3.amountsHeader File Limits:
    //  h3.amountsHeader Size: #{uploadLimitInMB}MB
    //  h3.amountsHeader Duration: 1 Hour

================
File: views/index/components/social-buttons.pug
================
.social
  a(href='https://github.com/mayeaux/generate-subtitles' target='_blank' rel='noreferrer' aria-label='GitHub Link')
    img#githubLogo(src='/images/inverted.png')
  a(href='https://discord.gg/vfXg7GHMpR' target='_blank' rel='noreferrer' aria-label='Discord Link')
    img#discordLogo(src='/images/discordLogo.png')
  a(href='https://t.me/freesubtitles_ai' target='_blank' rel='noreferrer' aria-label='Telegram Link')
    img#telegramLogo(src='/images/telegramLogo.webp')
  a(href='https://twitter.com/FreeSubtitlesAI' target='_blank' rel='noreferrer' aria-label='Twitter Link')
    img#twitterLogo(src='/images/twitterLogo.png')

================
File: views/index/components/transcription-results.pug
================
//DISPLAY DIFFERENT DATA
.transcription-data
  p#progress
  .progress
  p#timeEstimator
  p#latestData
  p#processingData
  p#secondProcessingData
  p#finishedData

  // kind of duplicated, not sure it's needed
  a#startNewUpload.startNewUpload.btn(onclick='(function(){ window.open(window.location.href, \'_blank\').focus(); })();') Start Another Transcription

.download-links
  a.btn.downloadLink#srtDownloadLink(href='#')

  a.btn.downloadLink#vttDownloadLink(href='#')

  a.btn.downloadLink#txtDownloadLink(href='#')

  a.btn#refreshButton(onclick='(function(){ window.open(window.location.href, \'_blank\').focus(); })();') Start New Transcription

================
File: views/index/components/upload-form.pug
================
style.

  .disabled-paste-button, .paste-button {
    display: inline-block;
    margin: 0;
    margin-left: 5px;
    cursor: pointer;
    color: #339233;
  }

  #downloadLinkLabel, .paste-button {
    /*pointer-events: none;*/

  }

  #disable-download-link {
    cursor: pointer !important;
  }

  .paste-button {
    /*pointer-events: ;*/
  }

  .file-turned-off {
    opacity: 0.5;
    pointer-events: none;
  }

  input::placeholder {
    color: #636262;
  }



form.form#form
  p(style="margin:0;margin-bottom:6px;") File Limits: Video Or Audio, Max 300 MB, Max 1 Hour Duration
  .group
    label(for='file') Select (or drop) file
    input#file(type='file')
  if !ytdlp
    .group
      label#disable-download-link(for='downloadLink') Enter a link for automatic download
        p.disabled-paste-button PASTE
      input(disabled #disable-download-link style="cursor:pointer;")(type='text' value="Paid Feature, More Info Coming Soon")
  if ytdlp
    label(for='downloadLink') Enter a link for automatic download
      p.paste-button PASTE
    input#downloadLink(type='text' placeholder="Enter a link to a video here")
  .group
    label(for='languageSelect')#languageLabel Language (#{languagesArray.length} Options)
    .wrapper
      button#languageSelect.select-btn(type='button')
        span#language.select-value(data-value='auto-detect' name='language') Auto-Detect
        i.fa-solid.fa-angle-down
      .content
        .search
          i.fa-solid.fa-magnifying-glass
          input(spellcheck='false' type='search' placeholder='Filter...' tabindex='0')
        ul.options.languages
          each language in languagesArray
            li.option(data-value=language.value tabindex='0')= language.name
  .group
    label(for='modelSelect')#modelLabel Model (#{modelsArray.length} Options)
    .wrapper
      button#modelSelect.select-btn(type='button')
        span#model.select-value(name='model')= modelsArray[0].name
        i.fa-solid.fa-angle-down
      .content
        .search
          i.fa-solid.fa-magnifying-glass
          input(spellcheck='false' type='search' placeholder='Filter...')
        ul.options.models
          each model in modelsArray
            li.option(data-value= model.value tabindex='0')= model.name
  .group.translateHolder
    label#translateLabel(for='translate') Translate to different languages
    input#translate(type='checkbox' name='translate')
  button#upload-button.submit-btn(type='submit') Upload


  script.
    let l = console.log;

    let pasteButtonTurnedOff = false;

    $(document).on('click', function (e) {

      // workaround since element is diabled
      if (e.target.attributes.getNamedItem('#disable-download-link')) {
        Swal.fire({
          title: `Restricted access feature`,
          text: 'This feature is too powerful for public use, reach out on one of the social media for access',
          icon: 'info',
          confirmButtonText: 'Back to Upload'
        })
      }
    });

    // TODO: add this download link
    function isValidLink(input) {
      const pattern = /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
      return pattern.test(input);
    }

    $('.paste-button').click(function(event) {
      l('clicked!');
      l('pasteButtonTurnedOff', pasteButtonTurnedOff);

      if(pasteButtonTurnedOff) {
        return;
      }

      navigator.clipboard.readText().then(clipText => {
        $('#downloadLink').val(clipText);
        updateCss()
      });
    });

    function updateCss(){
      const currentInputValue = $('#downloadLink').val();

      l('currentInputValue', currentInputValue);

      // if downloadlink is empty
      const inputIsEmpty = currentInputValue === '';

      // re-enable file input
      if (inputIsEmpty) {
        $('#file').removeClass('file-turned-off');
      } else {
      // disable file input
        l('turning off paste button')
        // re-enable file input and paste button
        $('#file').addClass('file-turned-off');
      }
    }

    $('#downloadLink').keyup(() => {
      updateCss()
    });

    $('#downloadLink').change(() => {
      updateCss()
    });

    $('#file').change(function () {
      // there was a file present
      if ($('#file')[0]?.files?.length > 0) {
        $('#downloadLink').addClass('file-turned-off');
        $('.paste-button').addClass('file-turned-off');

        $('#downloadLink').attr('placeholder', 'You have selected a file to upload');
        pasteButtonTurnedOff = true;

        l('file added')
      // a file that was there was removed
      } else {
        $('#downloadLink').removeClass('file-turned-off');
        $('.paste-button').removeClass('file-turned-off');

        $('#downloadLink').attr('placeholder', 'Enter a link to a video here');

        pasteButtonTurnedOff = false;


        l('file removed')
      }
    });

================
File: views/index/js/controllers/error-handling.pug
================
script.
  const errorsMap = {
    'no-file': () =>
      Swal.fire({
        title: `You didn't pass a file`,
        text: 'Please select a file to upload.',
        icon: 'error',
        confirmButtonText: 'Cool'
      }),
    'too-many-outstanding': () =>
      Swal.fire({
        title: `Slow down a bit`,
        text: 'You already have 3 outstanding jobs which is the maximum for now, please wait for one of them to finish before you upload another file',
        icon: 'error',
        confirmButtonText: 'Cool'
      }),
    'too-large-file': (size, sizeLimit) =>
      Swal.fire({
        title: `Too large file`,
        text: `Your file size of ${size}MB is too large. The limit is ${sizeLimit}MB.`,
        icon: 'error',
        confirmButtonText: 'Cool'
      }),
      'too-long-video': (duration, durationLimit) =>
        Swal.fire({
          title: `Too long video`,
          text: `Your video duration of ${duration / 60} minutes is too long. To share time more evenly 1h+ uploads are not allowed currently.`,
          icon: 'error',
          confirmButtonText: 'Cool'
        }),
      'transcription-error': text =>
        Swal.fire({
          title: 'Transcription Failed',
          text,
          icon: 'error',
          showCancelButton: true,
          confirmButtonText: 'Try Again',
        }).then(result => result.isConfirmed && window.location.reload()),
      'interrupted-connection': () =>
        Swal.fire({
          title: 'Websocket Disconnected',
          text: 'Your websocket connection was disconnected, please refresh to start a new upload',
          icon: 'error',
          showCancelButton: true,
          confirmButtonText: 'Refresh',
        }).then(result => result.isConfirmed && window.location.reload()),
  }

================
File: views/index/js/controllers/file-handling.pug
================
script.
  const getFirstFile = evt => {
    let list = new DataTransfer();
    let firstPassedFile = evt.dataTransfer.files[0];
    list.items.add(firstPassedFile);
    return list;
  }

  const getVideoDuration = file =>
    new Promise((resolve, reject) => {
      const reader = new FileReader();
      l({file});
      reader.onload = evt => {
        l({evt});
        l('loading');
        l({reader});
        const media = new Audio(reader.result);
        l(media);
        media.onerror = err => {
          ce({err});
          reject(err);
        }
        media.onloadedmetadata = () => resolve(media.duration);
      };
      l('reading')
      reader.readAsDataURL(file);
      reader.onerror = function(error){
        ce({error})
        reject(error);
      }
    });

================
File: views/index/js/controllers/network-handling.pug
================
script.
  const renderDownloadInfo = ({ data, circleProgress }) => {
    // let's use my algo for calculating the ETA because it's more accurate
    // therefore all we need is percentage
    // we'll calculate, seconds elapsed, seconds remaining

    l('data received from downloadInfo');
    l(data);

    const percentDownloaded = data.percentDownloaded;
    const startedAtTime = data.startedAtTime;
    const fileName = data.fileName;
    const totalFileSize = data.totalFileSize;
    const downloadSpeed = data.downloadSpeed;
    const {fileSizeUnit, fileSizeValue} = data;

    const differenceInMs = new Date() - new Date(startedAtTime);

    // get time in seconds between upload start time and now
    const timeElapsedInSeconds = Math.round(differenceInMs / 1000);
    // estimate how many seconds remaining based on percentage
    const estimatedTotalDownloadTimeInSeconds = Math.round(timeElapsedInSeconds * (100 / percentDownloaded));
    // time left is difference of estimated time and elapsed time
    const estSecondsRemaining = estimatedTotalDownloadTimeInSeconds - timeElapsedInSeconds;

    $('#timeEstimator').show();
    $('#progress').show()
    $('#header').html('Downloading..');
    $('#form').hide()
    $('#startNewUpload').show();


    $('#progress').html(`${percentDownloaded}% downloaded`);
    document.title = `${percentDownloaded}% Downloaded - ${fileName}`;

    circleProgress.attr({
      max: 100,
      value: Number(percentDownloaded),
    });

    if (percentDownloaded === 100) {
      circleProgress.attr({
        max: 100,
        value: 0,
      });
      $('.progress').hide();
    } else {
      $('.progress').show();
    }

    const estSecondsIsNan = isNaN(estSecondsRemaining);

    let timeRemainingString = '';
    if(estSecondsRemaining !== Infinity && !estSecondsIsNan) {
      timeRemainingString = `[${timeElapsedInSeconds}/${estSecondsRemaining}s] ${forHumans(estSecondsRemaining)} remaining`
    }

    const totalDownloaded = Number((fileSizeValue * (percentDownloaded / 100)).toFixed(2));
    const totalDownloadedANumber = isNaN(totalDownloaded)

    const frontendDisplayString = `
    ${timeRemainingString}

    Total File Size: ${totalFileSize || ''}
    Download Speed: ${downloadSpeed || ''}
    Total Downloaded: ${ totalDownloaded || ''}${totalDownloaded && fileSizeUnit || ''}

    Filename: ${fileName}
    `

    $('#timeEstimator').html(frontendDisplayString)
  }

  // global vars used for using in the decrementing function
  let globalEstimatedSecondsRemaining, globalTimeElapsedInSeconds, globalUploadedAmountInMB;

  const progressUpload = (evt, startDate, circleProgress, fileName) => {
    l(evt);
    $('#form').hide();
    $('#startNewUpload').show();

    const uploadedAmountInMB = _.round(evt.loaded / (1024 * 1024), 1);
    const totalFileSizeInMB = _.round(evt.total / (1024 * 1024), 1);
    const percentUpload = Math.round((uploadedAmountInMB / totalFileSizeInMB) * 100);
    // get time in seconds between upload start time and now
    const timeElapsedInSeconds = Math.round((new Date() - startDate) / 1000);
    // estimate how many seconds remaining based on percentage
    const estUploadTimeInSeconds = Math.round(timeElapsedInSeconds * (100 / percentUpload));
    // time left is difference of estimated time and elapsed time
    const estSecondsRemaining = estUploadTimeInSeconds - timeElapsedInSeconds;

    l({percentUpload});
    l({timeElapsedInSeconds});
    l({estSecondsRemaining});

    $('#progress').html(`${percentUpload}% uploaded`);
    document.title = `${percentUpload}% Uploaded - ${fileName}`;

    circleProgress.attr({
      max: 100,
      value: Number(percentUpload),
    });

    if (percentUpload === 100) {
      circleProgress.attr({
        max: 100,
        value: 0,
      });
      $('.progress').hide();
    } else {
      $('.progress').show();
    }

    globalEstimatedSecondsRemaining = estSecondsRemaining;
    globalUploadedAmountInMB = uploadedAmountInMB;
    globalTimeElapsedInSeconds = timeElapsedInSeconds;

    // start up functionality to update estimate every second
    if (!uploadStarted) {
      uploadStarted = true;
      setInterval(() => {
        const estSecondsIsInfinity = globalEstimatedSecondsRemaining === Infinity;
        const estSecondsIsNan = isNaN(globalEstimatedSecondsRemaining);
        const uploadSpeedInMBs = _.round((globalUploadedAmountInMB / globalTimeElapsedInSeconds), 1);

        const valueIsValid = !estSecondsIsInfinity && !estSecondsIsNan;
        if (!valueIsValid) return;

        $('#timeEstimator').html(`[${globalTimeElapsedInSeconds}/${globalEstimatedSecondsRemaining}s] ${forHumans(globalEstimatedSecondsRemaining)} remaining
          \n Total File Size: ${totalFileSizeInMB} MB, \nAlready Uploaded: ${globalUploadedAmountInMB} MB \nUpload Speed: ${uploadSpeedInMBs} MB/s,
          `);
      }, 1000)
    }
  }

  const loadAjax = ({ response, circleProgress }) => {
    if(downloadStarted) downloadFinished = true;
    if(transcriptionFailed) return
    l({response});
    $('#processingData').show();
    $('#latestData').show();
    $('#progress').hide();
    $('#timeEstimator').hide();
    $('#header').html('Processing..');
    circleProgress.attr({
      max: 100,
      value: 0,
    });
    $('.progress').show();
  }

  const renderQueue = ({place, log}) => {
    inTheQueue = true;
    l(log);
    let queueMessage;
    let titleMessage;
    let movingBackwardsInQueue = false;
    if(placeInQueue && place > placeInQueue) movingBackwardsInQueue = true;
    placeInQueue = place;
    if(place < 1){
      queueMessage = `Starting now...`;
    } else if (place === 1){
      queueMessage = `You're next up`;
    } else if (place === 2) {
      queueMessage = `There's 1 person ahead of you`;
      titleMessage = `1 person ahead of you`;
    } else {
      queueMessage = `There are ${place - 1} people ahead of you`;
      titleMessage = `${place - 1} people ahead of you`;
    }

    if(movingBackwardsInQueue){
      queueMessage = queueMessage + `\n\n Paid users can jump to the front of the line`
    }

    document.title = `${titleMessage || queueMessage}`;
    $('#latestData').html(queueMessage)
  }

  let latestProgress, globalTimeRemaining, myUploadStarted = false;

  const renderProcessingFeedback = ({data, hitTheBackend}) => {
    l('websocket data');
    let loopStarted;
    //- destructure the data object -osb910
    let {
      ownershipPerson,
      serverNumber: processNumber,
      percentDone,
      timeRemaining,
      processingData,
      formattedProgress
    } = data;
    const myUpload = ownershipPerson === 'you';

    // disregard any data that isn't yours after your processing has started
    if (!myUpload && myUploadStarted) return;

    latestProgress = formattedProgress;

    const fileName = $('#file').prop('files')[0]?.name;
    if (myUpload && percentDone) {
      document.title = `${percentDone}% Transcribed - ${fileName}`;
    }

    // by default let to 'latest processing'
    // TODO: this is misnamed, it's not the upload that's started but the processing
    let processFeedback = `Latest processing data (process ${processNumber})\n`;
    if (myUpload) {
      /** it's your upload **/
      // data is no longer relevant
      $('#secondProcessingData').hide();
      myUploadStarted = true; // force this to true
      processFeedback = ``;
      $('#latestData').hide();
    }

    // TODO: what does this eitherProcess check actually accomplish?
    // every second it grabs it from the ether and decrements it and rebuilds the string
    const eitherProcess = processNumber ===  1 || processNumber === 2;
    l({eitherProcess});

    const myUploadProcessing = myUpload && hitTheBackend && myUploadStarted

    // TODO: need my upload finished? && !myUploadFinished
    l({eitherProcess, myUpload, hitTheBackend, myUploadStarted});
    if (eitherProcess && myUploadProcessing) {
      l('found my data');
      $('#processingData').show();
      // actual process data coming back
      if (percentDone > 0) {
        circleProgress.attr({
          max: 100,
          value: percentDone,
        });

        if (percentDone === 100) {
          $('.progress').hide();
        } else {
          $('.progress').show();
        }

       globalTimeRemaining = timeRemaining;

        if (!window.decrementInterval) {
          // BUG: timer reaches 0 early because it's out of sync with the actual progress, maybe calculate it on the backend? -osb910
          window.decrementInterval = setInterval(() => {
            globalTimeRemaining = decrementBySecond(globalTimeRemaining);
            l({globalTimeRemaining});

            const progressUpdate =
            `[${latestProgress.percentDone}] ${globalTimeRemaining.string} Remaining, Speed ${latestProgress.speed}f/s`;

            $('#processingData').html(`${processFeedback}${progressUpdate}`);
          }, 1000);
        }

      } else {
        $('#processingData').html(`${processFeedback}Transcription starting soon..`);
      }
    }

    if(downloadStarted && !downloadFinished) return

    // TODO: this seems off
    // update the process 2 info if appropriate
    // TODO: this is misnamed, it's not the upload that's started but the processing
    if (!myUpload && !myUploadStarted && hitTheBackend && !myProcessingStarted) {
      l(`getting process ${processNumber} data`);
      // TODO: add decrementing here
      $(`${processNumber === 1 ? '#processingData' : '#secondProcessingData'}`).show();
      $(`${processNumber === 1 ? '#processingData' : '#secondProcessingData'}`).html(`${processFeedback}\n${data.processingData}`);
    }
  }

  const renderStartingFeedback = ({ data, circleProgress }) => {
    inTheQueue = false;
    document.title = `Starting processing..`;
    l('starting data');
    $('#latestData').html(data.text);
    $('#processingData').css({'font-size': '1.6rem'});
    $('#processingData').hide();
    $('#secondProcessingData').hide();
    myProcessingStarted = true;
    circleProgress.attr({
      max: 100,
      value: 100,
    });
    $('.progress').show();
    circleProgress.attr({
      max: 100,
      value: 0,
    });
    // $('#latestData').css("font-size", "20px");
  }

  const renderFileDetails = data => {
    l('file details data');
    const niceDate = new Date().toString().replace(/GMT.*/g, '');
    const niceString = `Started At: ${niceDate}`;
    $('#finishedData').html(data.fileDetails + niceString);
  }

  const renderTranslationUpdate = data => {
    l('language update data');
    // Get a reference to the last interval + 1
    const interval_id = window.setInterval(() => {
    }, Number.MAX_SAFE_INTEGER);

    // Clear any timeout/interval up to that id
    for (let i = 1; i < interval_id; i++) {
      window.clearInterval(i);
    }

    $('#processingData').html(data.languageUpdate);
  }

  const renderCompletionFeedback = ({data}) => {
    l('completed data');
    if (window.decrementInterval) clearInterval(window.decrementInterval);
    $('#latestData').html(`Congratulations, you're done!`);
    $('#finishedData').html(data.detailsString);
    $('#header').html('Transcription Completed');
    $('#processingData').hide();
    // show refresh button
    $('#refreshButton').hide();
    $('#startNewUpload').hide();
    // redirect to the player page
    // 2 seconds to let the user see the completion message
    setTimeout(() => window.location.href = `/player/${data.filename}`, 2000);
  }

  const renderError = data => {
    l('error data');
    transcriptionFailed = true;
    $('#latestData').hide()
    $('#processingData').show()
    $('#processingData').html(data.text);
  }

================
File: views/index/js/controllers/selection-dropdowns.pug
================
script.
  const updateSelection = option => {
    const selectedValueEl = option.closest('.wrapper').querySelector('.select-value');
    const selectedOption = option.closest('.wrapper').querySelector('.selected');
    selectedOption.classList.remove('selected');
    option.classList.add('selected');
    selectedValueEl.textContent = option.textContent;
    selectedValueEl.dataset.value = option.dataset.value;
  }

  const handleSelectionButtonClick = evt => {
    const selectWrapper = evt.target.closest('.wrapper');
    const input = selectWrapper.querySelector('.search input');
    selectWrapper.classList.toggle('active');
    selectWrapper.querySelector('.selected').scrollIntoView({block: 'center'}); // scroll to selected option // doesn't work for some reason // TODO
    input.focus();
  }

  const handleOptionClick = evt => {
    const option = evt.target;
    const selectWrapper = option.closest('.wrapper');
    updateSelection(option);
    selectWrapper.classList.remove('active');
    selectWrapper.querySelector('.select-btn').focus();
  }

  const handleSelectionShortcuts = evt => {
    const key = evt.key;
    ['ArrowDown', 'ArrowUp', 'Enter', 'Escape'].includes(key) && evt.preventDefault();

    const selectionContent = evt.target.closest('form .content');
    const focusedOption = document.activeElement.closest('.option');
    const focusedInput = document.activeElement.closest('input[type="search"]');

    const keysMap = [
      {command: /ArrowDown/, action: () => {
        //- focusedInput ? getNextVisibleSibling(selectionContent.querySelector('.selected'))?.focus()
        //- :
        // if there is a focused option, focus the next one, else focus the first one
        (getNextVisibleSibling(focusedOption) ??
        getFirstVisibleSibling(selectionContent.querySelector('.options')))
        .focus();
      }},

      {command: /ArrowUp/, action: () => {
        (getPreviousVisibleSibling(focusedOption) ??
        getLastVisibleSibling(selectionContent.querySelector('.options')))
        .focus();
      }},

      {command: /Enter/, action: () => focusedOption?.click()},
      
      {command: /Escape/, action: () => selectionContent.closest('.wrapper').classList.remove('active')},

      {command: /[a-z]/i, action: () => {
        selectionContent.querySelector(`input[type='search']`).focus();
      }},
    ];

    keysMap.find(({command}) => command.test(key))?.action();
  }

  const handleSelectionInput = evt => {
    const searchInput = evt.target;
    const options = Array.from(searchInput.closest('.content').querySelectorAll('.option'));
    const selectButton = searchInput.closest('.wrapper').querySelector('.select-btn');
    selectButton.id === 'languageSelect' && options.shift();
    const filteredOptions = filterOptions(options, searchInput.value);

    options.forEach(option => {
      filteredOptions.includes(option) 
      ? option.classList.remove('hidden')
      : option.classList.add('hidden');
    });
  }

================
File: views/index/js/js-index.pug
================
include js-util
include controllers/selection-dropdowns
include controllers/file-handling
include controllers/error-handling
include controllers/network-handling

script.
  l = console.log;
  ce = console.error;

  let ytdlp = !{ytdlp || false};
  const user = '#{user}';
  const skipToFront = '#{skipToFront}'

  l('ytdlp', ytdlp);
  l(ytdlp)

  // global variables
  let circleProgress, hitTheBackend, videoDurationInSeconds, filename, uploadStarted;
  let processStarted, processFailed, uploadFinished, processingData, timeRemaining;
  let downloadStarted, downloadFinished;
  let transcriptionFailed = false;
  let inTheQueue;
  let receivedPlaceInQueue, myProcessingStarted = false;
  let placeInQueue = 0;
  const oneHourInSeconds = 60 * 60;

  // setup endpoints to hit
  const ipAndPort = location.host;
  const randomNumber = Math.round(Math.random() * 1_000_000_000_000);
  const protocol = window.location.protocol;
  const servedWithSSL = protocol.slice(0, -1) === 'https';
  const httpPrepend = protocol === 'https:' ? 'https' : 'http';
  const wssPrepend = protocol === 'https:' ? 'wss' : 'ws';

  // websocket server
  const websocketAndServerEndpoint = `${wssPrepend}://${ipAndPort}/${randomNumber}`

  // connect to server
  const websocketConnection = new WebSocket(websocketAndServerEndpoint);

  // file endpoint
  const uploadUrl = `${httpPrepend}://${ipAndPort}/file`;

  // check outstanding jobs endpoint
  const checkAmountOfOutstandingJobsUrl = `${httpPrepend}://${ipAndPort}/checkingOutstandingProcesses`;

  // passed from server
  const isFreeSubtitles = !{isFreeSubtitles};
  const uploadLimitInMB = !{uploadLimitInMB};
  const nodeEnvironment = `!{nodeEnv}`;
  const decrementBySecond = !{decrementBySecond};
  const forHumans = !{forHumans};

  // grab elements
  const languageOptions = Array.from(document.querySelectorAll('.options.languages .option'));
  const modelOptions = Array.from(document.querySelectorAll('.options.models .option'));

  // local storage
  const previousModel = localStorage.getItem('model');
  const previousModelName = localStorage.getItem('modelName');
  const previousLanguage = localStorage.getItem('language');
  const previousLanguageName = localStorage.getItem('languageName');
  const previousShouldTranslate = localStorage.getItem('shouldTranslate');

  $(document).ready(() => {
    // start progress at 100 and rewind it when starting
    // I did this by accident the first time but I like it so I kept it
    circleProgress = new CircleProgress('.progress', {
      max: 100,
      value: 100,
      textFormat: 'vertical',
    });

    //-  Add selected class to both selected options or default to first option -osb910
    const selectedLang = languageOptions.find(opt => opt.dataset.value === previousLanguage) || languageOptions[0];
    const selectedModel = modelOptions.find(opt => opt.dataset.value === previousModel) || modelOptions.find(opt => opt.dataset.value === 'medium');

    selectedLang.classList.add('selected');
    selectedModel.classList.add('selected');

    //- Populate previous values from local storage -osb910
    //- jquery doesn't work here for some reason, strange bug -osb910
    //- $('#model').data('value', (previousModel || 'medium'));
    //- $('#language').data('value', (previousLanguage || 'auto-detect'));
    document.querySelector('#model').dataset.value = previousModel || 'medium';
    document.querySelector('#language').dataset.value = previousLanguage || 'auto-detect';

    $('#model').text(previousModelName || 'Medium');
    $('#language').text(previousLanguageName || 'Auto-Detect');
    $('#translate').prop('checked', previousShouldTranslate === 'true');

    l('ready now');
  });

  // handle clicks with event delegation -osb910
  $('body').on('click', evt => {
    const clicked = evt.target;
    const selectWrappers = document.querySelectorAll('#form .wrapper');
    const selectionBtn = clicked.closest('.select-btn');
    const option = clicked.closest('.option');
    const groupElement = clicked.closest('.form .group');

    const langSelectionBtn = clicked.closest('.select-btn#languageSelect');
    langSelectionBtn && selectWrappers[1].classList.remove('active');

    selectionBtn && handleSelectionButtonClick(evt); // On selection button click

    option && handleOptionClick(evt); // On option click

    !groupElement && selectWrappers.forEach(wrapper => wrapper.classList.remove('active')); // On outside form group click
  });

  // handle input with event delegation -osb910
  $('body').on('input', evt => {
    // Elements
    const pressed = evt.target;
    const selectWrapper = pressed.closest('form .wrapper');
    selectWrapper && handleSelectionInput(evt);
  });

  // handle key press with event delegation -osb910
  $('body').on('keydown', evt => {
    const pressed = evt.target;
    const selectionContent = pressed.closest('form .content');

    selectionContent && handleSelectionShortcuts(evt);
  });

  $('#form').on('submit', submitForm);

  // freezes everything up
  // $('#file').on('change', async () => {
  //   videoDuration = await getVideoDuration($('#file').prop('files')[0]);
  //   l({videoDuration});
  // });

  async function submitForm(evt) {
    evt.preventDefault();

    const outstandingJobsResponse = await fetch(checkAmountOfOutstandingJobsUrl);
    const outstandingJobsText = await outstandingJobsResponse.text();

    if(outstandingJobsText === 'tooMany') {
      return errorsMap['too-many-outstanding']()
    }

    /* DATA */
    const formData = new FormData();
    const [passedFile] = $('#file').prop('files');
    const fileName = passedFile?.name;
    let language = $('#language').data('value');
    const model = document.querySelector('#model').dataset.value;
    const modelName = document.querySelector('#model').textContent;
    const translateIsChecked = $('#translate').is(':checked');
    const downloadLink = $('#downloadLink').val()

    function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }

    //- set local storage
    localStorage.setItem('model', model);
    localStorage.setItem('modelName', modelName);
    localStorage.setItem('language', language);
    let languageName;
    if (language === 'auto-detect') {
      languageName = 'Auto-Detect';
    } else {
      languageName = capitalizeFirstLetter(language);
    }
    localStorage.setItem('languageName', languageName);
    localStorage.setItem('shouldTranslate', translateIsChecked);

    //- gather data
    if (passedFile) formData.append('file', passedFile);
    if (downloadLink) formData.append('downloadLink', downloadLink);
    if (user) formData.append('user', user);
    if (skipToFront) formData.append('skipToFront', skipToFront);
    formData.append('language', language);
    formData.append('model', model);
    formData.append('shouldTranslate', translateIsChecked);
    formData.append('websocketNumber', randomNumber);

    /* SUBMIT ERRORS */
    if(!passedFile && !downloadLink) return errorsMap['no-file']();

    // TODO: pull into its own function
    // frontend validation of file size and file length
    if (nodeEnvironment === 'production' && isFreeSubtitles && passedFile) {

    // force upload testing
    // if(true){
      // TODO: pass max file size from server
      const passedFileSizeInMB = Math.round(passedFile.size / 1048576);

      // swal with the error
      if (passedFileSizeInMB > uploadLimitInMB) {
        // put back upload button
        $('#upload-button').html('Upload').removeClass('no-pointer-events');
        return errorsMap['too-large-file'](passedFileSizeInMB, uploadLimitInMB);
      }

      // checking the upload duration
      $('#upload-button').addClass('no-pointer-events');
      $('#upload-button').html('Checking your upload length..')

      try {
        l('getting duration');
        videoDurationInSeconds = await getVideoDuration(passedFile);
        l({videoDurationInSeconds});
      } catch (err){
        /// just let them advance if there's an error, happens with .MOV (format error)
        //  and uploads over 500MB (because of Chrome)
        ce(err);
      }

      // TODO: pass time limit from backend
      if (videoDurationInSeconds && videoDurationInSeconds > oneHourInSeconds) {
        $('#upload-button').html('Upload').removeClass('no-pointer-events');
        videoDurationInSeconds = 0;
        return errorsMap['too-long-video'](videoDurationInSeconds);
      }
    }

    // Display the key/value pairs
    for (const pair of formData.entries()) {
      console.log(pair[0] + ': ' + pair[1]);
    }

    $('.amountsHeader').hide();

    // warn user about leaving if they're still processing
    window.addEventListener('beforeunload', (event) => {
      if(!uploadFinished && !processFailed){
        // per modern browsers text doesnt actually show up just a generic message
        event.returnValue = `You have an ongoing transcription and if you leave you have to start over. Are you sure you want to leave?`;
      }
    });

    /** AJAX **/
    const ajax = new XMLHttpRequest();
    const submitDate = new Date();

    /** upload progress / countdown functionality **/
    if(!downloadLink) ajax.upload.addEventListener('progress', evt => progressUpload(evt, submitDate, circleProgress, fileName));

    ajax.addEventListener('error', err => ce(err), false);

    function handleReadyStateChange(){
      l('ready state change');
      if (ajax.readyState === XMLHttpRequest.DONE) {
        if (ajax.status === 200) {
          // Request has completed successfully, do something
        } else {
          processFailed = true;
          l('failed request');
          l(ajax.responseText);
          // Request has failed, do something
          return errorsMap['transcription-error'](ajax.responseText);
        }
      }
    };

    // handle request to backend failing
    ajax.addEventListener('readystatechange', handleReadyStateChange)

    function loadEvent(){
      l('hit the backend!');
      hitTheBackend = true;
      const response = ajax.responseText;
      if (response === 'download') {

      } else {
        loadAjax({response, circleProgress});

      }
    }

    // once backend is hit
    ajax.addEventListener('load', loadEvent)

    // TODO: implement these
    // ajax.addEventListener("abort", abortHandler, false);

    // hit the backend
    ajax.open('POST', uploadUrl);
    ajax.send(formData);
    $('#form').hide()
    if(downloadLink) downloadStarted = true;
  }

  // prompt user to refresh if websocket dies
  websocketConnection.onclose = evt => {
    l('websocket closed');
    processFailed = true;
    // dont show popup if websocket closed because finished
    if (uploadFinished) return;
    return errorsMap['interrupted-connection']();
  };

  /** handling websocket messages **/
  websocketConnection.onmessage = evt => {
    const data = JSON.parse(evt.data);
    const {message, status} = data;
    l({data});

    // processing data is received constantly from backend
    const isProcessingInfo = message === 'websocketData';

    // queue related (first info and decrementing)
    const sendingQueueInformation = message === 'queue';

    // TODO: queue implementation is actually off, because if someone behind you leaves
    // it decrements the queue number though you didn't actually move up a position
    const differentUserHasFinishedProcessing = data === 'finishedProcessing';

    const transcriptionIsStarting = message === 'starting';

    const isFileDetailsMessage = message === 'fileDetails';

    const isTranslationUpdate = message === 'languageUpdate';

    const transcriptionHasCompleted = status === 'Completed';

    const isErrorMessage = message === 'error';

    const isDownloadingInfo = message === 'downloadInfo';

    const downloadingIsFinished = message === 'downloadingFinished';

    isDownloadingInfo && renderDownloadInfo({data , circleProgress });

    downloadingIsFinished && loadAjax({circleProgress})

    // WEBSOCKET DATA COMING FROM THE BACKEND
    isProcessingInfo && renderProcessingFeedback({data, hitTheBackend});

    sendingQueueInformation && renderQueue({place: data.placeInQueue, log: 'initial queue data'});

    transcriptionIsStarting && renderStartingFeedback({ data, circleProgress });

    isFileDetailsMessage && renderFileDetails(data);

    //- updates about translations on backend
    isTranslationUpdate && renderTranslationUpdate(data);

    /** WHEN WEBSOCKET SAYS COMPLETED **/
    if (transcriptionHasCompleted) {
      uploadFinished = true;
      renderCompletionFeedback({data});
      websocketConnection.close();
    }

    isErrorMessage && renderError(data);

    if (!transcriptionHasCompleted && !sendingQueueInformation && !differentUserHasFinishedProcessing && !isProcessingInfo && !isFileDetailsMessage && !isTranslationUpdate && !isErrorMessage && !transcriptionIsStarting) {
      // TODO: try and deprecate this use eventually from backend
      l('else data');
      $('#latestData').html(data);
    }
  };

  /** DRAG AND DROP FILES **/
  $('html').bind('dragover dragenter', evt => evt.preventDefault());

  document.documentElement.ondrop = evt => {
    evt.preventDefault();
    // only add the first file
    const list = getFirstFile(evt);
    evt?.dataTransfer?.files
    ? $('#file').prop('files', list.files)
    : l('no files found');
  }

================
File: views/index/js/js-util.pug
================
script.
  const unescapeHTML = escapedHTML => escapedHTML
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&');

  const filterOptions = (options, q) => {
    const regex = new RegExp(`^${q}`, 'i');
    return options.filter(opt => !!opt.dataset.value.match(regex));
  }

  //- get next, previous, first, and last visible siblings with recursion

  const getNextVisibleSibling = el => el?.nextSibling?.classList.contains('hidden')
    ? getNextVisibleSibling(el.nextSibling) : el?.nextSibling;

  const getPreviousVisibleSibling = el => el?.previousSibling?.classList.contains('hidden')
    ? getPreviousVisibleSibling(el.previousSibling) : el?.previousSibling;

  const getFirstVisibleSibling = el => el?.firstChild?.classList.contains('hidden')
    ? getNextVisibleSibling(el.firstChild) : el?.firstChild;
  
  const getLastVisibleSibling = el => el?.lastChild?.classList.contains('hidden')
    ? getPreviousVisibleSibling(el.lastChild) : el?.lastChild;

================
File: views/index/styles/styles-amounts-header.pug
================
style.
  .amountsHeader {
    text-align: center;
    color: white;
    font-size: 21px;
  }

  .amountsHeader:nth-of-type(1) {
    margin-bottom: -1px;
  }

  .amountsHeader:nth-of-type(2) {
    margin-top: 11px;
  }

  .fileLimitsDiv {
    padding-bottom: 3px;
  }

  .firstHeader {
    margin-top: -75px;
    margin-bottom: 59px;
  }

================
File: views/index/styles/styles-form.pug
================
style.
  form {
    padding: 30px;
    display: flex;
    flex-direction: column;
    gap: 1em;
    background-color: white;
    font-size: 0.9rem;
  }

  form :where(input:not([type='checkbox']), .select-btn) {
    padding: 0.5em 1em;
    width: 100%;
    border: 1px solid #ccc;
    font-size: inherit;
  }

  form .group {
    display: flex;
    flex-direction: column;
    gap: 0.5em;
  }

  form .group .wrapper {
    position: relative;
    width: 100%;
  }

  .select-btn, li{
    width: 100%;
    padding: 10px 16px;
    display: flex;
    align-items: center;
    cursor: pointer;
  }

  .select-btn {
    background: transparent;
    justify-content: space-between;
  }

  .select-btn i {
    font-size: 1.5rem;
    transition: transform 250ms ease-in-out;
  }

  .wrapper.active .select-btn i {
    transform: rotate(-180deg);
  }

  .content {
    position: absolute;
    top: 3.5rem;
    z-index: 1;
    width: 100%;
    display: none;
    flex-direction: column;
    visibility: hidden;
    opacity: 0;
    max-height: 0;
    padding: 16px;
    padding-bottom: 0;
    background: #fff;
    box-shadow: 0 10px 25px rgba(0,0,0,0.1);
    transition: max-height 250ms ease-in-out;
  }

  .wrapper.active .content{
    display: flex;
    visibility: visible;
    opacity: 1;
    max-height: 350px;
  }

  .content .search {
    position: relative;
    display: flex;
    align-items: center;
    height: 2.5rem;
    gap: 0.5em;
  }

  .search i {
    color: #999;
    font-size: 1.25rem;
    pointer-events: none;
  }

  .search input {
    flex-grow: 1;
    outline: none;
    font-size: 1rem;
    padding: 0.5em 0.75em;
    border: 1px solid #B3B3B3;
  }

  .search input:focus{
    border: 2px solid #4285f4;
  }

  .search input::placeholder{
    color: #bfbfbf;
  }

  .search input::-webkit-search-cancel-button {
    cursor: pointer;
    font-size: 1.25em;
  }

  .content .options {
    display: flex;
    flex-direction: column;
    gap: 0.5em;
    margin-top: 10px;
    overflow-y: auto;
    padding-inline: 0.5em;
    background-color: #fff;
  }

  .options::-webkit-scrollbar{
    width: 7px;
  }

  .options::-webkit-scrollbar-track{
    background: #f1f1f1;
    border-radius: 1rem;
  }

  .options::-webkit-scrollbar-thumb{
    background: #ccc;
    border-radius: 1rem;
  }

  .options::-webkit-scrollbar-thumb:hover {
    background: #b3b3b3;
  }

  .options li {
    margin: 0;
    font-size: 1rem;
  }

  .options li:where(:hover, :focus, .selected) {
    border-radius: 5px;
    background: hsl(0deg 0% 90%);
  }

  .options li:focus {
    outline: 0;
    box-shadow: 0 0 3px #4285f4;
  }

  #languageLabel, #modelLabel, #translateLabel, #translate {
    cursor: pointer;
  }

  #translate {
    position: relative;
    height: 1.1rem;
    width: 1.1rem;
    opacity: 0.8;
    margin-left: 2px;
  }


  .group.translateHolder {
    flex-direction: row;
    gap: 0.5em;
    align-items: center;
  }

  .submit-btn {
    width: 100%;
    border: none;
    background: rgb(60, 57, 57);
    font-size: 18px;
    color: white;
    border-radius: 3px;
    padding: 20px;
    text-align: center;
    cursor: pointer;
  }

================
File: views/index/styles/styles-social.pug
================
style.
  
  .social {
    width: 130px;
    position: absolute;
    right: 30px;
    display: flex;
    flex-direction: column;
    gap: 0.6em;
  }

  .social a {
    padding: 0.5em 1em;
    transition: all 200ms ease-in-out;
  }

  .social a:where(:hover, :focus) {
    transform: scale(1.1);
  }

  .social img {
    width: 100%;
  }

  #twitterLogo {
    margin-top: -14px;
  }

================
File: views/index/styles/styles-transcription-results.pug
================
style.

  .transcription-data {
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 0.75em;
    font-size: 1.25rem;
    color: #fff;
  }

  .downloadLink, #refreshButton, #startNewUpload {
    color: white;
    font-size: 1.05rem;
    text-align: center;
  }

  #timeEstimator {
    font-size: 1.25rem;
    text-align: center;
  }

  #finishedData {
    text-align: left;
    font-size: 1.125rem;
    color: white;
    margin-top: -12px;
    margin-left: -44px;
    margin-bottom: 7px;
  }

  #latestData, #processingData, #secondProcessingData, #refreshButton, #startNewUpload, .downloadLink {
    display: none;
  }

  #refreshButton, #startNewUpload {
    text-decoration: underline;
  }

  .startNewUpload {
    --color: #fff;
    color: var(--color);
    margin-block: 0.5em;
    margin-top: -10px;
  }

  #latestData, #processingData, #secondProcessingData, #timeEstimator, #finishedData {
    white-space: pre;
  }

  .downloadLink {
    color: white;
    font-size: 1.25rem;
  }

  .circle-progress-value {
    stroke-width: 50px;
    stroke: hsl(160, 63%, 55%);
  }

  .circle-progress-circle {
    stroke-width: 50px;
    stroke: #999;
  }

  .circle-progress-text {
    fill: white;
  }

  .progress svg {
    height: 202px;
    width: 202px;
  }

  .circle-progress-value {
    stroke-width: 50px;
    stroke: white;
  }

  .circle-progress-text {
    fill: black;
    font-size: 1.1rem;
  }

  .circle-progress-circle {
    stroke-width: 50px;
    stroke: #bdbdbd;
  }

  .progress {
    display: none;
    margin: 0 auto;
    text-align: center;
  }

  #progress, #latestData {
    font-size: 1.6rem;
  }

  #latestData {
    margin: 0 auto;
  }

  #processingData {
    margin: 14px auto;
    line-height: 17px;
  }

  #secondProcessingData {
    line-height: 17px;
  }

================
File: views/index/index.pug
================
extends ../layout

block content
  script(src='/javascripts/circle-progress.min.js')

  include ../styles/styles-global
  include styles/styles-social
  include styles/styles-amounts-header
  include styles/styles-form
  include styles/styles-transcription-results

  include components/social-buttons

  .container

    include components/amounts-header

    h1#header File Upload
    include components/upload-form

    include components/transcription-results
  
  include js/js-index

================
File: views/player/js/captionsDisplay.pug
================
script.
  function setStoredLineHeightAndFontSizeIfExists() {
    const storedLineHeight = localStorage.getItem('storedLineHeight');
    if (storedLineHeight) {
      subtitlesLineHeight = storedLineHeight;
      $('.plyr__caption').css('line-height', storedLineHeight);
    } else {
      const currentLineHeight = $('.plyr__caption').css('line-height');
      localStorage.setItem('storedLineHeight', currentLineHeight);
    }

    const storedFontSize = localStorage.getItem('storedFontSize');
    if (storedFontSize) {
      // l('found font size');
      // l(storedFontSize)
      subtitlesFontSize = storedFontSize;

      $('.plyr__caption').css('font-size', storedFontSize);
    } else {
      const currentFontSize = $('.plyr__caption').css('font-size');
      localStorage.setItem('storedFontSize', currentFontSize);
    }
  }

  function adjustFontSize(direction) {

    const currentLineHeight = $('.plyr__caption').css('line-height');
    const currentLineHeight1 = currentLineHeight.replace('px', '');
    const newLineHeight = parseInt(currentLineHeight1) + (direction === 'increase' ? 1 : -1);

    const currentFontSize = $('.plyr__caption').css('font-size');
    const currentFontSize1 = currentFontSize.replace('px', '');
    const newFontSize = parseInt(currentFontSize1) + (direction === 'increase' ? 1 : -1);

    l('subtitlesFontSize', subtitlesFontSize)
    l('subtitlesLineHeight', subtitlesLineHeight)

    const newLineHeightWithPx = `${newLineHeight}px`;
    const newFontSizeWithPx = `${newFontSize}px`;

    $('.plyr__caption').css('line-height', newLineHeightWithPx);
    $('.plyr__caption').css('font-size', newFontSizeWithPx);

    localStorage.setItem('storedLineHeight', newLineHeightWithPx);
    localStorage.setItem('storedFontSize', newFontSizeWithPx);

    subtitlesFontSize = newFontSizeWithPx;
    subtitlesLineHeight = newLineHeightWithPx;

  }

  function adjustLineHeight(direction) {
    const currentLineHeight = $('.plyr__caption').css('line-height');
    const currentLineHeight1 = currentLineHeight.replace('px', '');
    const newLineHeight = parseInt(currentLineHeight1) + (direction === 'increase' ? 1 : -1);


    const newLineHeightWithPx = `${newLineHeight}px`;

    // l('subtitlesLineHeight', subtitlesLineHeight)

    $('.plyr__caption').css('line-height', newLineHeightWithPx);

    localStorage.setItem('storedLineHeight', newLineHeightWithPx);

    subtitlesLineHeight = newLineHeightWithPx;
  }

================
File: views/player/js/secondCaptions.pug
================
script.
  function findIndexNumber(language, text) {
    const video = $('video')[0]
    const textTracks = video.textTracks;

    let foundIndex;
    let index = 0;
    for (const track of textTracks) {
      const trackLanguage = track.label
      if (language === trackLanguage) {
        for (const cue of track.cues) {
          if (cue.text === text) {
            foundIndex = index
          }
          index++
        }
      }
    }

    return foundIndex
  }

  function loadTextTracks() {
    const video = $('video')[0]
    const textTracks = video.textTracks;
    for (const track of textTracks) {
      track.mode = 'hidden';
    }
  }
  loadTextTracks()

  function findTextFromIndexNumber(language, index) {
    const video = $('video')[0]
    const textTracks = video.textTracks;

    let text;
    // l('text tracks');
    // l(textTracks);

    for (const track of textTracks) {
      const trackLanguage = track.label
      if (language === trackLanguage) {
        text = track.cues[index]?.text
        return text
      }
    }
    return false;
  }

  function getCurrentLanguageAndTrack() {
    const video = $('video')[0]
    const textTracks = video.textTracks;
    const trackNumber = player.currentTrack;
    const currentTrack = textTracks[trackNumber]

    const language = currentTrack.label;
    const text = currentTrack.activeCues?.[0]?.text;

    const indexNumber = findIndexNumber(language, text);

    return {
      language,
      text,
      indexNumber
    }
  }

  function getSecondCaptionsDefaults() {
    let secendCaptionsDefaults = localStorage.getItem('secondCaptionsDefaults')
    if (!secendCaptionsDefaults) {
      localStorage.setItem('secondCaptionsDefaults', JSON.stringify({}))
      return {}
    } else {
      secendCaptionsDefaults = JSON.parse(secendCaptionsDefaults)
      return secendCaptionsDefaults
    }
  }

  function setSecondCaptionsDefaults(secondCaptionsLanguage) {
    const secondCaptionsDefaults = getSecondCaptionsDefaults()
    secondCaptionsDefaults[language] = secondCaptionsLanguage;
    localStorage.setItem('secondCaptionsDefaults', JSON.stringify(secondCaptionsDefaults))
  }

  function buildMenuItemString(language, index) {
    return `<button data-plyr="language" id="languageName" type="button" role="menuitemradio" class="plyr__control" aria-checked="false" value="${index}">
                  <span id="languageValue" value="${language.name}">${language.name}<span class="plyr__menu__value"><span class="plyr__badge">${language.languageCode.toUpperCase()}</span></span></span>
              </button>`;
  }

  const disabledMenuItem = `
             <button data-plyr="language" type="button" role="menuitemradio" class="plyr__control" aria-checked="true" value="-1">
                <span>Disabled</span>
            </button>`;

  function createSecondCaptionsSetting() {
    const menuText = `${disabledMenuItem}
                    ${allLanguages.map((language, index) => {
      return buildMenuItemString(language, index)
    }).join('')}`;

    // show second caption option in popup
    $('.plyr__menu__container > div > div > div > button')[1].removeAttribute('hidden')

    // write Second Captions name with Disabled as default on popup
    $('.plyr__menu__container > div > div > div > button').eq(1).html('<span>Second Captions<span class="plyr__menu__value">Disabled</span></span>');

    // add menu items for when you click the button
    $("div[id*='secondCaptions'] div").html(menuText)

    // set default chosen value as Disabled
    $("div[id*='secondCaptions'] button span").eq(0).text('Disabled')

    // handle when language value is clicked
    $("div[id*='secondCaptions'] div button").click(function () {
      // mark all languages as not checked
      $("div[id*='secondCaptions'] div button").attr("aria-checked", "false");

      // get language of clicked value
      let languageValue = $(this).children().text();

      // remove last two characters from string (couldn't get only French instead of FrenchFR)
      if (/[A-Z]{2}$/.test(languageValue)) {
        languageValue = languageValue.slice(0, -2);
      }

      setSecondCaptionsDefaults(languageValue)

      // get current vtt text
      const currentLang = getCurrentLanguageAndTrack();

      const originalLanguage = $('div[role="menu"]').eq(0).children(1).children(1).eq(0).children(1).text();

      const originalText = findTextFromIndexNumber(originalLanguage, currentLang.indexNumber);

      const translationText = findTextFromIndexNumber(languageValue, currentLang.indexNumber);

      // const originalText = $("span.plyr__caption").text();

      // mark language as activated
      $(this).attr("aria-checked", "true");

      // update text at the top of the menu options
      $("div[id*='secondCaptions'] button span").eq(0).text(languageValue)

      // immediately add text if they didn't select Disabled
      if (languageValue !== 'Disabled') {
        $("span.plyr__caption").text(`${originalText}\n${translationText}`);
      }

      // update text on secondCaptions option
      $('.plyr__menu__container > div > div > div > button').eq(1)
        .find('span.plyr__menu__value')
        .text(languageValue)

      // click back button (mirrors plyr functionality)
      $("div[id*='secondCaptions'] button span").eq(0).click()
    })
  }

================
File: views/player/js/videoProgress.pug
================
script.
  function getStoredVideoProgress() {
    const storedVideoProgress = localStorage.getItem('storedVideoProgress');
    if (storedVideoProgress) {
      return JSON.parse(storedVideoProgress);
    }
    return {};
  }

  function setStoredVideoProgress(ended) {
    const storedVideoProgress = getStoredVideoProgress();
    if (ended) {
      storedVideoProgress[filename] = 0;
    } else {
      storedVideoProgress[filename] = player.currentTime;
    }
    localStorage.setItem('storedVideoProgress', JSON.stringify(storedVideoProgress));
  }

================
File: views/player/player.pug
================
extends ../layout

block content

    include ../styles/styles-global
    include styles-player

    main
      section.video-container
        video#player(playsinline controls='' autoplay='true' name='media' preload="auto")
          // file extension includes the .
          source(src=`${filePathWithoutExtension}${processingData.fileExtension}`)
          // TODO: replace with loop (has to fix on the backend)
          if languagesToLoop.length > 0
            each loopLanguage in languagesToLoop
              track(kind='captions' label=loopLanguage.name srclang=loopLanguage.languageCode src=`${filePathWithoutExtension}_${loopLanguage.name}.vtt` default='')
            track(kind='captions' label=processingData.language srclang=processingData.languageCode src=`${filePathWithoutExtension}_${processingData.language}.vtt` default=true)
          else
            track(kind='captions' label=processingData.language srclang=processingData.languageCode src=`${filePathWithoutExtension}.vtt` default=true)
      section.bottomSection
        .buttons
          button.btn#increaseSize Subtitle Text Size +
          button.btn#decreaseSize Subtitle Text Size -
          button.btn#increaseLineHeight Subtitle Spacing +
          button.btn#decreaseLineHeight Subtitle Spacing -
          button.btn#showHideControls Hide Text
        .downloadLinks
          a.btn.startAnotherTranscription(href='/') Start Another Transcription

          // ORIGINAL LANGUAGE FILES
          if processingData.translatedLanguages.length > 1
            span Original Language:
          .srtLinks.links
            span SRT (#{processingData.language})
            a(download href=`${filePathWithoutExtension}.srt`) Download
          .vttLinks.links
            span VTT (#{processingData.language})
            a(href=`${filePathWithoutExtension}.vtt`) View
            a(download href=`${filePathWithoutExtension}.vtt`) Download
          .txtLinks.links
            span TXT (#{processingData.language})
            a(href=`${filePathWithoutExtension}.txt`) View
            a(download href=`${filePathWithoutExtension}.txt`) Download

          // TRANSLATED FILES //
          if processingData.translatedLanguages.length > 0
            p#translationsHeader Translations:
          // translated VTT files
          each language in processingData.translatedLanguages
            .links
              span VTT (#{language})
              a(href=`${filePathWithoutExtension}_${language}.vtt`) View
              a(href=`${filePathWithoutExtension}_${language}.vtt` download) Download
          .links
            a(download href=`${filePathWithoutExtension}${processingData.fileExtension}`) Download File
        .fileDetails
          each property, value in processingData
            p #{value}: #{property}
        #addTranslation
          a(href=`/player/` + renderedFilename + `/add` style="text-decoration:none;")
            p(style="color:rgb(22, 29, 29);") Add Here
              //p Filename: #{processingData.filename}
        if userAuthed
          form(action='/player/#{renderedFilename}/keepMedia?password=#{password}&keepMedia=true' method='POST')
            // form elements go here
            button(type='submit') Keep Media True
          br
          form(action='/player/#{renderedFilename}/keepMedia?password=#{password}&keepMedia=false' method='POST')
            // form elements go here
            button(type='submit') Keep Media False
          br

          //a(href='/player/#{renderedFilename}/add?password=#{password}&keepMedia=true' style="text-decoration:none;")
          //  p(style="") Add Here
          //a(href=`/player/` + renderedFilename + `/add` style="text-decoration:none;")
          //  p(style="color:rgb(22, 29, 29);") Add Here

    script(src = 'https://cdn.plyr.io/3.7.2/plyr.js')
    link(rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/plyr/3.7.2/plyr.css' integrity='sha512-SwLjzOmI94KeCvAn5c4U6gS/Sb8UC7lrm40Wf+B0MQxEuGyDqheQHKdBmT4U+r+LkdfAiNH4QHrHtdir3pYBaw==' crossorigin='anonymous' referrerpolicy='no-referrer')
    script.
      l = console.log;

      let player;
      let subtitlesFontSize, subtitlesLineHeight;

      const language = '#{processingData.language}';
      const languagesToLoop = !{JSON.stringify(languagesToLoop)};
      const allLanguages = !{JSON.stringify(allLanguages)};
      const filename = '#{renderedFilename}';

      l('all languages');
      l(allLanguages);

      $(document).ready(function () {

        let bottomTextShown = true;
        $('#showHideControls').click(function(){

          if(bottomTextShown){
            $('.downloadLinks').hide()
            $('.fileDetails').hide()
            $('#addSubtitles').hide()
            bottomTextShown = false;
            $(this).text('Show Text');

          } else {
            $('.downloadLinks').show()
            $('.fileDetails').show()
            $('#addSubtitles').show()
            bottomTextShown = true;
            $(this).text('Hide Text');
          }
          l('clicked!');
        })

        // make all links open in new tab
        const anchorTags = document.querySelectorAll('a');
        anchorTags.forEach((anchor) => {
          anchor.setAttribute('target', '_blank');
        });

        $('#increaseSize').click(function (event) {
          adjustFontSize('increase');
        });

        $('#decreaseSize').click(function (event) {
          adjustFontSize('decrease');
        });

        $('#increaseLineHeight').click(function (event) {
          adjustLineHeight('increase');
        });

        $('#decreaseLineHeight').click(function (event) {
          adjustLineHeight('decrease');
        });

        console.log("ready!");
        var controls =
          [
            'progress', // The progress bar and scrubber for playback and buffering
            'play-large', // The large play button in the center
            // 'restart', // Restart playback
            // 'rewind', // Rewind by the seek time (default 10 seconds)
            'play', // Play/pause playback
            // 'fast-forward', // Fast forward by the seek time (default 10 seconds)
            'volume', // Volume control
            'volume-slider',
            'current-time', // The current time of playback
            'duration', // The full duration of the media
            'mute', // Toggle mute
            'captions', // Toggle captions
            'settings', // Settings menu
            // 'pip', // Picture-in-picture (currently Safari only)
            // 'airplay', // Airplay (currently Safari only)
            // 'download', // Show a download button with a link to either the current source or a custom URL you specify in your options
            'fullscreen'
          ];

        player = new Plyr('#player', {
          disableContextMenu: true,
          controls,
          captions: { active: true, language: 'auto', update: true },
          settings: ['captions', 'secondCaptions']
        });

        player.on('ready', event => {
          // change position of volume button
          $('.plyr__volume').append($('.plyr__volume').children('').get().reverse());

          // without this timeout it doesn't work properly
          setTimeout(function(){
            setStoredLineHeightAndFontSizeIfExists();
          }, 200)

        });

        let intervalId;
        player.on('playing', event => {
          l('playing');
          intervalId = setInterval(function () {
            // Run your function here
            setStoredVideoProgress();
          }, 5000);
        })

        player.on('pause', event => {
          clearInterval(intervalId);
          setStoredVideoProgress();
          l('pause');
        })

        player.on('ended', event => {
          clearInterval(intervalId);
          setStoredVideoProgress(true);
          l('ended');
        })

        // ChatGPT says this should work but doesn't for me
        // player.on('pause, ended', event => {
        //   clearInterval(intervalId);
        //   l('pause or ended!');
        // })

        // l('captions');

        player.on('loadeddata', () => {
          const currentStoredProgress = getStoredVideoProgress()[filename];
          l('currentStoredProgress', currentStoredProgress);
          if (currentStoredProgress) {
            player.currentTime = currentStoredProgress;
          }
        })

        // probably better to do on plyr ready if available as event
        setTimeout(function(){

          if (allLanguages.length > 1) {
            createSecondCaptionsSetting();
          }

          $(function () {
            $('.plyr__captions').draggable({
              containment: 'plyr',
              // drag: function (event, ui) {
              // }
            });
          });


          const captionsIsPressed = $('button[data-plyr="captions"]')?.hasClass('plyr__control--pressed')

          if (!captionsIsPressed) {
            $('button[data-plyr="captions"]').click();
          }

          let haveSetupSecondCaptions = false;
          // set secondsDefault language
          player.on('playing', function(){
            const currentSecondLanguageDefaults = getSecondCaptionsDefaults()
            // l('currentSecondLanguageDefaults', currentSecondLanguageDefaults)
            // l(language);
            if(!haveSetupSecondCaptions){
              setTimeout(function () {
                // open menu
                $('.plyr__menu').children().eq(0).click()
                const presetLanguage = currentSecondLanguageDefaults[language];
                if (presetLanguage) {
                  // set preset value
                  $(`span#languageValue[value="${presetLanguage}"]`).parent().click();
                  // close menu
                  $('.plyr__menu').children().eq(0).click()
                  haveSetupSecondCaptions = true;
                }
              }, 10)
            }
          })

          player.on('cuechange', function (event) {
            const text = event.detail.plyr.captions.currentTrackNode.activeCues[0]?.text;
            const thing = getCurrentLanguageAndTrack()
            // l(thing);

            const selectedTranslation = $("#languageName[aria-checked='true'] > span[id*='languageValue']").attr("value");
            if(selectedTranslation && selectedTranslation !== 'Disabled') {
                const translation = findTextFromIndexNumber(selectedTranslation, thing.indexNumber);
                const originalText = $('span.plyr__caption').text();

                $('span.plyr__caption').text(`${originalText}\n${translation || ''}`);
            }

            // balance text not working at the moment
            if(subtitlesFontSize){
              $('.plyr__caption').css('font-size', subtitlesFontSize);
            }

            if(subtitlesLineHeight){
              $('.plyr__caption').css('line-height', subtitlesLineHeight);
            }
            // l(text);
          })
        }, 200)
      });
    include js/secondCaptions
    include js/captionsDisplay
    include js/videoProgress

================
File: views/player/styles-player.pug
================
style.

  main {
    display: flex;
    flex-direction: column;
    gap: 0.5em;
  }

  video {
    position: relative;
    inset: 0;
    max-height: 100vh;
    max-width: 100vw;
    margin: auto;
    object-fit: contain;
    height: 100%;
    width: 100%;
  }

  .pulled-right {
    max-width: 500px;
    margin-right: 0px;
    width: 200px;
    position: relative;
    float: right;
    top: -6px;
  }

  .video-title {
    font-size: 58px;
    margin-top: 25px;
  }

  .hide-cursor {
    cursor: none;
  }

  .plyr {
    max-height: 94.6vh;
  }

  #back-button {
    font-size: 14px;
    margin-top: 12px;
  }

  #download-button {
    font-size: 14px;
    margin-top: 5px;
  }

  .upload-details-holder {
    /*height: 1300px;*/
  }

  .upload-details h4:not(.description) {
    font-size: 35px;
  }

  .vjs-text-track-display div div {
    font-size: 40px !important;
  }

  .video-js {
    max-height: 400px;
  }

  .bottomSection {
    color: #fff;
    padding-inline: 1.25em;
    font-size: 1rem;
  }

  .buttons {
    width: fit-content;
    display: flex;
    gap: 0.5em;
  }

  .buttons .btn {
    margin: 0;
    border: 0;
    margin-right: 8px;
    font-size: 14px;
  }

  .buttons :where(#increaseSize:hover, #increaseLineHeight:hover)  {
    color: #55ed55;
  }

  .buttons :where(#decreaseSize:hover, .buttons #decreaseLineHeight:hover) {
    color: #df2b2b;
  }

  .downloadLinks {
    display: flex;
    flex-direction: column;
    gap: 0.5em;
  }

  #translationsHeader {
    margin-bottom: 1px;
  }

  .links {
    display: flex;
    gap: 1em;
    margin-top: 5px;
  }

  .downloadLinks, .fileDetails {
    font-size: 14px;
  }

  .startAnotherTranscription {
    margin: 0 0;
  }

  @media (min-width: 320px) {
    /* smartphones, portrait iPhone, portrait 480x320 phones (Android) */
  }

  @media (min-width: 480px) {
    /* smartphones, Android phones, landscape iPhone */
  }



  /** larger than this size **/
  @media (min-width: 320px) {

    .plyr__captions  .plyr__caption {
        font-size: 21px;
        line-height: 33px;
    }
  }

  @media (min-width: 801px) {

    .plyr__captions  .plyr__caption {
      font-size: 21px;
      line-height: 33px;
    }
    /* tablet, landscape iPad, lo-res laptops ands desktops */
  }

  @media (min-width: 1025px) {
    /* big landscape tablets, laptops, and desktops */
  }

  /* not mobile */
  @media (min-width: 1281px) {
    .plyr__captions .plyr__caption {
      font-size: 21px;
      line-height: 33px;
    }
    /* hi-res laptops and desktops */
  }

  @media (max-width: 900px) {
    .plyr__volume {
      display: none !important;
    }

    .plyr__time--current, .plyr__time--duration {
      font-size: 24px !important;
    }

    body {
      //- font-size: 28px;
    }

    .plyr__control svg {
      width: 53px !important;
      height: 53px !important;
    }


    button[data-plyr="language"], button[data-plyr="settings"] {
      font-size: 28px !important;
    }

    /* hi-res laptops and desktops */
  }

  .plyr__poster {
    display: none;
  }

  .plyr .plyr__captions {
    display: inline-table !important;
    text-align: left !important;
    cursor: pointer;
    max-width: 99%;
    z-index: 9999;
    padding: 0px;
    width: unset !important;
    position: absolute;
    bottom: 68px;
  }

  .plyr:not(.plyr--hide-controls) .plyr__controls:not(:empty)~.plyr__captions {
    transform: unset !important;
  }

  .plyr__caption {
    text-wrap: balance;
    display: block;
  }

  .plyr__controls {
    flex-wrap: wrap;
    justify-content: left !important;
  }

  .plyr__progress__container {
    flex-basis: 100% !important;
  }

  .plyr__progress {
    max-width: 99%;
    text-align: center;
    margin: 0 auto;
    margin-bottom: 5px;
  }

  button[data-plyr=captions] {
    margin-left: auto !important;
  }

  input[data-plyr=seek], input[data-plyr=volume] {
    cursor: pointer;
  }

================
File: views/stats/stats.pug
================
extends ../layout

block content
    style.
        video {
            top: 0px;
        }

        #transcriptionAmountTable tbody tr th, #transcriptionTimeTable tbody tr th {
            text-align: left;
            width: 168px;
        }

        #transcriptionAmountTable tbody tr th {
            text-align: left;
            width: 100px;
        }

        #languageName {
            width: 155px;
            text-align: left;
        }


    div
        h1 Stats

        h2 Completed Transcriptions

        table#transcriptionAmountTable
            tbody
                tr
                    th Last Hour
                    th Last Day
                    th Last Week
                    th Last Month
                    th All-Time
                tr
                    td #{stats.lastHour}
                    td #{stats.last24h}
                    td #{stats.lastWeek}
                    td #{stats.lastMonth}
                    td #{stats.allTime}

        br
        h2 Transcription Time

        table#transcriptionTimeTable
            tbody
                tr
                    th Last Hour
                    th Last 24h
                    th Last Week
                    th Last Month
                    th All-Time
                tr
                    td #{transcriptionTime.lastHour}
                    td #{transcriptionTime.last24h}
                    td #{transcriptionTime.lastWeek}
                    td #{transcriptionTime.lastMonth}
                    td #{transcriptionTime.allTime}


        br
        h2 Transcribed Languages
        table#languages
            tbody
                tr
                    th#languageName Language Name
                    th Amount

              each pair in Object.entries(languages)
                  tr
                      td #{pair[0]}
                      td #{pair[1]}
                  //li= pair[0] + ': ' + pair[1]
              // each language in languages
              //     tr
              //         td #{language}

                    //td #{languages.language}
                    //td #{transcriptionTime.lastWeek}
                    //td #{transcriptionTime.lastMonth}
                    //td #{transcriptionTime.allTime}



    script.
      l = console.log;

      $(document).ready(function () {

      });

================
File: views/styles/styles-global.pug
================
style.
  html {
    scroll-behavior: smooth;
  }
  
  body {
    background-color: rgb(22, 29, 29);
    padding: 0;
    margin: 0;
  }

  * {
    box-sizing: border-box;
  }

  .container {
    max-width: 500px;
    margin: 140px auto;
  }

  .container h1 {
    text-align: center;
    color: white;
  }

  .no-pointer-events {
    pointer-events: none;
  }

  .btn {
    width: fit-content;
    display: inline-block;
    padding: 0.5em 0;
    margin: 0 auto;
    background-color: transparent;
    font-size: inherit;
    color: inherit;
    border-color: currentColor;
    text-decoration: underline;
    cursor: pointer;
    transition: all 200ms ease;
  }

  a {
    color: inherit;
  }

  .hidden {
    display: none;
  }

================
File: views/admin.pug
================
extends layout

block content
    style.
        p {
            margin: 2px auto;
        }


    div
        h1 Admin
        br

        h2 Job Processes (#{Object.keys(jobProcesses).length})
        p global.jobProcesses
        br
        each val, key in jobProcesses
            p Process Number: #{key}
            br
            if val
                each val2, key2 in val
                    p #{key2}: #{val2}
            br

        br
        h2 New Queue Items (#{newQueue && newQueue.length})
        p global.newQueue
        br

        each item, index in newQueue
            p Place In Queue: #{index + 1}
            each val, key in item
                p #{key}: #{val}
            br
        br

        br
        h2 Transcription/Download Processes (#{transcriptions && transcriptions.length})
        p global.transcriptions
        br
        each item in transcriptions
          each val, key in item
              p #{key}: #{val}
          br
        br

        h2 Websocket Connections (#{webSocketData && webSocketData.length})
        p global.webSocketData
        br
        each item in webSocketData
            each val, key in item
                p #{key}: #{val}
            br

================
File: views/error.pug
================
extends layout

block content
  h1= message
  h2= error.status
  pre #{error.stack}

================
File: views/files.pug
================
extends layout

block content
    style.
        video {
            top: 0px;
        }


    div
        h1 Files

        table#myTable
            tbody
                tr
                    th Filename
                    th Language
                    th Keep Media
                    th Duration
                    th Date


                each file in files
                    tr

                      td(data-sort-value=file.name)
                          a(href='/player/' + file.name target="_blank") #{file.name}
                      td(data-sort-value=file.processingData.language) #{file.processingData.language}
                      td(data-sort-value=file.processingData.keepMedia) #{file.processingData.keepMedia}
                      td(data-sort-value=file.processingData.uploadDurationInSeconds data-type="number") #{file.processingData.uploadDurationInSecondsHumanReadable}
                      td(data-sort-value=file.timestamp data-type) #{file.formattedDate}


    script.
      l = console.log;

      $(document).ready(function () {
        console.log("ready!");

        // probably better to do on plyr ready if available as event
        setTimeout(function(){
          // const captionsIsPressed = $('button[data-plyr="captions"]')?.hasClass('plyr__control--pressed')

        }, 200)

        function convertToNumber(string) {
          const number = Number(string);
          if (isNaN(number)) {
            // If the string is not a valid number, return 0
            return 0;
          } else {
            // If the string is a valid number, return the number
            return number;
          }
        }

        var table = document.getElementById("myTable");
        var currentSort = null; // Keep track of the current sort column

        table.addEventListener("click", function (event) {
          // Get the element that was clicked
          var element = event.target;

          // If the element is a table header, sort the table by the corresponding column
          if (element.tagName == "TH") {
            // Get the index of the column that was clicked
            var index = Array.prototype.indexOf.call(element.parentNode.children, element);

            // If the same column was clicked twice, reverse the sort order
            if (currentSort === index) {
              currentSort = -1 * currentSort;
            } else {
              currentSort = index;
            }

            // Sort the table by the values in the clicked column
            sortTable(table, index, currentSort);
          }
        });

        function sortTable(table, column, sortOrder) {
          // Get the rows of the table
          var rows = table.rows;

          // Convert the rows to an array (we'll need to sort this array)
          var rowArray = Array.prototype.slice.call(rows, 1);

          // Sort the array of rows according to the values in the specified column
          rowArray.sort(function (a, b) {
            // Get the text content of the cells in the specified column
            var A = a.cells[column].getAttribute("data-sort-value");
            var B = b.cells[column].getAttribute("data-sort-value");

            // Check if the values are numeric or not
            if (isNaN(A) || isNaN(B)) {
              // Compare the values as strings
              if (sortOrder > 0) {
                if (A < B) return -1;
                if (A > B) return 1;
                return 0;
              } else {
                if (A > B) return -1;
                if (A < B) return 1;
                return 0;
              }
            } else {
              // Convert the values to numbers and compare them
              A = parseFloat(A);
              B = parseFloat(B);
              if (sortOrder > 0) {
                if (A < B) return -1;
                if (A > B) return 1;
                return 0;
              } else {
                if (A > B) return -1;
                if (A < B) return 1;
                return 0;
              }
            }
          });

          // Remove the existing rows from the table
          while (rows.length > 1) {
            table.deleteRow(1);
          }

          // Add the sorted rows back to the table
          rowArray.forEach(function (row) {
            table.appendChild(row);
          });
        }


      });

================
File: views/layout.pug
================
doctype html
html
  head
    title= title
    link(rel='stylesheet', href='/stylesheets/style.css')
    link(rel='icon' href='/favicon.ico?v=1.1')
    link(rel='apple-touch-icon' href='/images/favicon.ico')
    script(src='//cdn.jsdelivr.net/npm/sweetalert2@11')
    script(src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js' integrity='sha512-aVKKRRi/Q/YV+4mjoKBsE4x3H+BkegoM/em46NNlCqNTmUYADjBbeNefNxYV7giUp0VxICtqdrbqU7iVaeZNXA==' crossorigin='anonymous' referrerpolicy='no-referrer')
    script(src='https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js' integrity='sha512-WFN04846sdKMIP5LKNphMaWzU7YpMyCU245etK3g/2ARYbPK9Ub18eG+ljU96qKRCWh+quCY7yefSmlkQw1ANQ==' crossorigin='anonymous' referrerpolicy='no-referrer')
    script(src='https://code.jquery.com/ui/1.13.2/jquery-ui.min.js' integrity='sha256-lSjKY0/srUM9BE3dPm+c4fBo1dky2v27Gdjm2uoZaL0=' crossorigin='anonymous')
    script(src='https://cdnjs.cloudflare.com/ajax/libs/balance-text/3.3.1/balancetext.min.js' integrity='sha512-LYmOcKYUkf2fYuZ4qCuLjIsJHAV1IbRFng30BKotYho3D8LG5R9Ehl4N3AMxQUJ3ANkWAJ4UVe62t36h4RId2g==' crossorigin='anonymous' referrerpolicy='no-referrer')
    //- Font Awesome icons are used in the custom dropdowns
    script(src='https://kit.fontawesome.com/109728983b.js' crossorigin='anonymous')
  body
    block content

================
File: views/queue.pug
================
extends layout

block content
    style.
        p {
            margin: 2px auto;
        }


    div
        h1 Queue

        each queueItem in queueData
          each val, key in queueItem
              p= key + ': ' + val
          br

================
File: .env.sample
================
CONCURRENT_AMOUNT=1
# uncomment this if you have LibreTranslate running locally
#LIBRETRANSLATE='http://127.0.0.1:5000'
UPLOAD_FILE_SIZE_LIMIT_IN_MB=100
MULTIPLE_GPUS=false
FILES_PASSWORD=password
NODE_ENV='development'

================
File: .eslintrc.js
================
module.exports = {
  env: {
    browser: true,
    commonjs: true,
    es2021: true,
  },
  overrides: [],
  parserOptions: {
    ecmaVersion: 'latest',
  },
  ignorePatterns: ['public/*'],
  rules: {
    'quotes': ['error', 'single'],
    'space-before-blocks': ['error', 'always'],
    'space-before-function-paren': ['error', 'always'],
    'keyword-spacing': ['error', { 'before': true, 'after': true }],
    'no-var': 'error'
  },
};

================
File: .gitignore
================
node_modules
.idea
assets
test
uploads
transcriptions
transcriptions1
downloads

public/javascripts/ffmpeg-core.wasm
.env

constants/apiTokens.txt

api-transcriptions
scripts/output-audio.aac
scripts/trimmed.mp4

================
File: app.js
================
const express = require('express');
const path = require('path');
const favicon = require('serve-favicon');
const logger = require('morgan');
const cookieParser = require('cookie-parser');
const bodyParser = require('body-parser');
const { WebSocketServer } = require('ws');
const fs = require('fs');
const {createServer} = require('http');
const sessions = require('express-session');
const _ = require('lodash');
l = console.log;
const { deleteOldFiles } = require('./scripts/deleteTranscriptionUploads');

// Load the .env file
require('dotenv').config();

const { createWebSocketServer } = require('./lib/websockets');

l('node env');
l(process.env.NODE_ENV);

// run stats gathering
require('./lib/stats');

// Check if the .env file exists
if (!fs.existsSync('.env')) {
  // If the .env file does not exist, copy the .env.sample file to .env
  fs.copyFileSync('.env.sample', '.env');
}

const hourInMilliseconds = 1000 * 60 * 60;

function runDeleteLoop () {
  setTimeout(() => {
    deleteOldFiles(true);
    runDeleteLoop();
  }, hourInMilliseconds);  // repeat every 1000 milliseconds (1 second)
}

if (process.env.NODE_ENV === 'production') {
  deleteOldFiles(true);
  runDeleteLoop();
}

l(`FILES PASSWORD: ${process.env.FILES_PASSWORD}`);

const routes = require('./routes/index');
const users = require('./routes/users');
const api = require('./routes/api');
const stats = require('./routes/stats');
const player = require('./routes/player');
const transcribe = require('./routes/transcribe');
const admin = require('./routes/admin');

const app = express();
const server = createServer(app);

createWebSocketServer(server);

l = console.log;

// l = function(l) {
//   var stack = (new Error()).stack.split(/\n/);
//   // Chrome includes a single "Error" line, FF doesn't.
//   if (stack[0].indexOf('Error') === 0) {
//     stack = stack.slice(1);
//   }
//   var args = [].slice.apply(arguments).concat([stack[1].trim()]);
//   return console.log(console, args);
// }
const port = process.env.PORT || '3000';
app.set('port', port);

// create folders if they don't exist yet
// fs.mkdirSync('uploads', { recursive: true })
fs.mkdirSync('uploads', { recursive: true })
fs.mkdirSync('transcriptions', { recursive: true })

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'pug');

app.use(favicon(path.join(__dirname,'public','images','favicon.ico')));
app.use(logger('dev'));
app.use(bodyParser.json({ limit: '1mb' }));
app.use(bodyParser.urlencoded({ extended: true, limit: '1mb' }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));
// assumes nginx
// if(!isProd){
  // TODO: this isn't secure if the API key is there
  app.use(express.static(__dirname));
// }

const oneWeek = 1000 * 60 * 60 * 24 * 7;

//session middleware
app.use(sessions({
  secret: (Math.random() * 1000000000).toString(),
  cookie: { maxAge: oneWeek },
  saveUninitialized: false,
  resave: false
}));

app.use(function (req, res, next) {
  const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress;
  l('IP Address')
  l(ipAddress);
  next();
})

app.use('/', routes);
app.use('/', api);
app.use('/users', users);
app.use('/', stats);
app.use('/', transcribe);
app.use('/', admin);
app.use('/', player);

// catch 404 and forward to error handler
app.use(function (req, res, next) {
  let err = new Error('Not Found');
  err.status = 404;
  next(err);
});

// error handlers

// development error handler
// will print stacktrace
if (app.get('env') === 'development') {
  app.use(function (err, req, res, next) {
    l(err);

    res.status(err.status || 500);
    res.render('error', {
      message: err.message,
      error: err
    });
  });
}

// production error handler
// no stacktraces leaked to user
app.use(function (err, req, res, next) {
  l(err);
  res.status(err.status || 500);
  res.render('error', {
    message: err.message,
    error: {}
  });
});

l(`Server listening on port ${port}`)

server.listen(port);

module.exports = app;

================
File: package.json
================
{
  "name": "init",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "start": "node app.js",
    "dev": "nodemon app.js",
    "lint": "eslint .",
    "lint-fix": "eslint . --fix"
  },
  "nodemonConfig": {
    "ignore": [
      "transcriptions/*",
      "uploads/*"
    ]
  },
  "dependencies": {
    "await-spawn": "^4.0.2",
    "axios": "^1.1.3",
    "body-parser": "^1.20.1",
    "cookie-parser": "~1.3.5",
    "cyrillic-to-latin": "^2.0.0",
    "debug": "^4.3.4",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "express-session": "^1.17.3",
    "ffprobe": "^1.1.2",
    "filenamify": "^4.3.0",
    "form-data": "^4.0.0",
    "fs-extra": "^10.1.0",
    "google-translate-api-browser": "^3.0.0",
    "language-name-map": "^0.3.0",
    "lodash": "^4.17.21",
    "moment": "^2.29.4",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "node-fetch": "^2.6.7",
    "promise-queue": "^2.2.5",
    "pug": "^3.0.2",
    "serve-favicon": "^2.5.0",
    "srt2vtt": "^1.3.1",
    "which": "^3.0.0",
    "ws": "^8.10.0",
    "yt-dlp-wrap": "^2.3.11",
    "zh-convert": "^1.0.1"
  },
  "devDependencies": {
    "eslint": "^8.30.0"
  }
}

================
File: README.md
================
# generate-subtitles

Generate transcripts for audio and video content with a user friendly UI, powered by Open AI's Whisper with automatic translations powered by LibreTranslate. Live for free public use at https://freesubtitles.ai

## Installation:
Under the hood, `generate-subtitles` uses Whisper AI for creating transcripts and Libretranslate for generating the translations. Libretranslate is optional and not required to run the service.

You can find the installation instructions for Whisper here: https://github.com/openai/whisper#setup

Once Whisper is installed and working properly, you can start the web server.

Make sure you are running Node.js 14+

`nvm use 14`

You can install Node 14 with `nvm`:

```shell
# install nvm
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash

# setup nvm
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

nvm install 14
nvm use 14
```

Currently the app uses `yt-dlp` as well, you can install it with:

```shell
sudo curl -L https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp -o /usr/local/bin/yt-dlp #download yt-dlp
sudo chmod a+rx /usr/local/bin/yt-dlp  # Make executable
```

Then:

```shell
git clone https://github.com/mayeaux/generate-subtitles
cd generate-subtitles
npm install
npm start
```

This should start the server at localhost:3000, at which point if you navigate to there with a browser you should be able to see and use the app.

## Using a GPU Cloud Provider
Note: Unless you have a GPU that can use CUDA, you will likely have to use your CPU to transcribe which is significantly less performant, hence why you may have to rent a GPU server from a cloud provider. The only GPU cloud provider that I've had a good experience with is VastAI which is what I use to run https://freesubtitles.ai , if you use this link I should receive a 2.5% of your purchase for the referral: http://vast.ai/?ref=52232

To setup the Vast server to run Whisper, you can use the following script: 
https://github.com/mayeaux/generate-subtitles/blob/master/docs/install.sh (Note, this script isn't perfect yet but has all the ingredients you need).

While creating the Vast server, you will have to open some ports, this is the configuration I use to achieve that:

Hit `EDIT IMAGE & CONFIG..`

<img src="https://user-images.githubusercontent.com/7200471/207619301-5cdbf85e-8b6e-479a-8562-0d7d01bea715.JPG" width="500" alt="Screen Shot 2022-12-14 at 3 15 48 PM" />


I select CUDA though it's not 100% necessary

<img src="https://user-images.githubusercontent.com/7200471/207619367-ce4779fc-8d21-4120-8f21-22bb179eb601.JPG" alt="Screen Shot 2022-12-14 at 3 15 58 PM" width="600" />

Then hit the `SELECT` button (the one that's to the right of the CUDA description and not the one next to cancel) and you can add this line to open the ports:
`-p 8081:8081 -p 8080:8080 -p 80:80 -p 443:443 -p 3000:3000 -p 5000:5000`

<img src="https://user-images.githubusercontent.com/7200471/207619664-4baeae12-9139-40bd-b4a3-2ac9bf4dffc3.JPG" alt="Screen Shot 2022-12-14 at 3 16 22 PM" width="600" />

Hit `SELECT & SAVE` and when you create an instance it should have the proper ports opened to be able to access the web app. Vast uses port forwarding so when your port 3000 is opened it will be accessed through another port but you should be able to figure that out from their interface.
